<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dynamic effects of health insurance reform</title>
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<link rel="stylesheet" href="./css/Latex.css">
<link rel="stylesheet" href="https://latex.now.sh/prism/prism.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>

<script src="http://orgmode.org/org-info.js">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
// @license-end
</script>

<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "showall");
org_html_manager.setup();  // activate after the parameters are set
// @license-end
</script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Dynamic effects of health insurance reform</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgc0a6c2c">How does this work?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></a></li>
<li><a href="#org32dc781">preamble&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></a>
<ul>
<li><a href="#orgac2b94d">loading data</a></li>
<li><a href="#org5306fd1">creating cohort data</a></li>
</ul>
</li>
<li><a href="#org8f87a13">1. Introduction</a></li>
<li><a href="#org0908337">2. Theory</a>
<ul>
<li><a href="#org8695b2c">2.1. Markov chain graph&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></a></li>
</ul>
</li>
<li><a href="#orgcc21baa">3. Data</a>
<ul>
<li><a href="#org416b1af">3.1. data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></a></li>
</ul>
</li>
<li><a href="#org71a2565">4. Estimation</a>
<ul>
<li><a href="#org305f468">4.1. Identification strategy and limitations</a></li>
<li><a href="#orgc4000e1">4.2. estimation code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></a>
<ul>
<li><a href="#org176c85b">choice of priors</a></li>
<li><a href="#org7750cdf">sampling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgfd2702b">5. Results</a>
<ul>
<li><a href="#orgd2870af">5.1. Model fit</a></li>
<li><a href="#org8e80046">5.2. Analysis</a></li>
<li><a href="#orge69bae2">5.3. model fit&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></a></li>
<li><a href="#org68a1897">5.4. results&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></a></li>
<li><a href="#org72d7b60">5.5. do analysis&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></a>
<ul>
<li><a href="#org3cb10cd">sensitivity analysis \(\theta\)</a></li>
<li><a href="#orgbaf41ba">comparison to (<a href="#citeproc_bib_item_4">Finkelstein and McKnight 2008</a>)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org03b6065">6. Extensions</a>
<ul>
<li><a href="#org5f86cee">6.1. Data</a></li>
<li><a href="#org01bc715">6.2. Extension of the model</a></li>
<li><a href="#org528add7">6.3. Placebo treatment</a></li>
<li><a href="#org9231d16">6.4. Different qaly values</a></li>
<li><a href="#org62320b8">6.5. reading the data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></a></li>
<li><a href="#org6abf9b5">6.6. extended model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></a>
<ul>
<li><a href="#org9b37aed">sampling</a></li>
</ul>
</li>
<li><a href="#org18186f3">6.7. placebo treatment: traffic mortality&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></a>
<ul>
<li><a href="#org4b9d9b8">model</a></li>
<li><a href="#org185a38e">sampling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0eec779">7. Discussion and policy implications</a></li>
<li><a href="#org8025f66">8. Bibliography</a></li>
<li><a href="#org1a41241">9. Data</a></li>
<li><a href="#orga14992a">10. Estimation</a></li>
</ul>
</div>
</div>
<div class="abstract" id="org137a8a6">
<p>
We estimate a dynamic structural model to assess the long-term health effects of demand-side cost-sharing. Using Eurostat regional data for 11 European countries (2008–2018), we track health transitions across cohorts defined by age, gender, income, and region. Our model shows that increased out-of-pocket payments reduce recovery rates, especially for low-income individuals. The resulting loss in quality-adjusted life years (qaly&rsquo;s) is significantly larger than what static estimates imply &#x2013;up to twenty times higher for vulnerable groups. These findings highlight the importance of accounting for long-term dynamics in policy evaluation and underscore the unequal burden of cost-sharing on population health.
</p>

</div>


<p>
<b>JEL codes:</b> I11, I13, I18
</p>

<p>
<b>Keywords:</b> out-of-pocket payments, mortality, health insurance, poverty, unmet medical needs
</p>


<p>
<p class="author">Author: Jan Boone</p>
</p>
<div id="outline-container-orgc0a6c2c" class="outline-2">
<h2 id="orgc0a6c2c">How does this work?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></h2>
<div class="outline-text-2" id="text-orgc0a6c2c">
<p>
With this document, the reader can retrace the code which we use to produce the results, figures, tables etc. for this paper.
</p>

<p>
This file is written in <a href="https://www.gnu.org/software/emacs/">Emacs</a> <a href="https://orgmode.org/">org mode</a> which allows us to combine text and code. The file is exported to pdf (via latex) and to html for the web-version. The web-version &#x2013;which you are reading now&#x2013; contains the sections tagged <code>code</code> which are not exported to the pdf version of the paper.
</p>

<p>
Here you can download <a href="./dynamic-effects-of-health-insurance-reform.pdf">the pdf of the paper</a>.
</p>

<p>
For the export to html we use <a href="https://github.com/vincentdoerig/latex-css">LaTeX.CSS</a> with some small tweaks to make it compatible with the org-exporter that we use which is based on <a href="https://github.com/jkitchin/org-ref">org-ref</a>. The export of the org file to html is almost perfect, but some issues are not yet resolved. To illustrate, the html export has trouble with latex environments like <code>align</code>, <code>split</code> in equations etc. For the time being this is resolved by using multiple <code>equation</code> environments. Further, whereas latex drops the label on equations that are not cited, the html exporter is not able to do this. Hence, there are more numbered equations in the web-version of the paper. This is all a bit clumsy but otherwise works fine.
</p>

<p>
We use <a href="https://www.python.org/">Python</a> to program the model and <a href="https://docs.pymc.io/">PyMC</a> for the Bayesian analysis. All these resources are open source and freely available. If you want to install Python, <a href="https://www.anaconda.com/products/individual">Anaconda</a> is a good place to start.
</p>

<p>
To avoid replicating code that is used for different models, we use <a href="https://orgmode.org/manual/Noweb-Reference-Syntax.html">noweb</a>. This is used as follows. First, we give the code block a name, like <code>code-preamble</code>. When we want to use this code, we call the code block by <code>&lt;&lt;code-preamble&gt;&gt;</code>.
</p>

<p>
There is a separate <a href="./getting_data.html">file</a> which describes how we get the data from Eurostat.
</p>

<p>
The repository for the paper can be found <a href="https://github.com/janboone/dynamic-effects-of-health-insurance-reform">here</a>.
</p>
</div>
</div>
<div id="outline-container-org32dc781" class="outline-2">
<h2 id="org32dc781">preamble&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></h2>
<div class="outline-text-2" id="text-org32dc781">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>code-header</label><pre class="src src-jupyter-python" id="orgf3e0273"><span style="color: #4e5059; font-style: italic;">#########################################################</span><span style="color: #4e5059; font-style: italic;">
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">This file is tangled from the index.org file in the root directory
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">the author runs the code from the index.org file directly in emacs
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">if you do not have emacs, you can run the code to generate the trace files
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">from this file
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">the file expects the following folder structure to run without problems:
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">the folder with the data should be located at: ./data/oop_health_data.nc
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">the trace files are written to ./trace
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">figures are written to ./figures
</span><span style="color: #4e5059; font-style: italic;">#########################################################</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>code-preamble</label><pre class="src src-jupyter-python" id="org3b7ed1f"><span style="color: #b877db;">import</span> matplotlib.pyplot <span style="color: #b877db;">as</span> plt
plt.style.use(<span style="color: #fab795;">'Solarize_Light2'</span>)
<span style="color: #b877db;">import</span> numpy <span style="color: #b877db;">as</span> np
<span style="color: #b877db;">from</span> numpy.lib.stride_tricks <span style="color: #b877db;">import</span> sliding_window_view
<span style="color: #b877db;">import</span> scipy <span style="color: #b877db;">as</span> sc
<span style="color: #b877db;">import</span> pandas <span style="color: #b877db;">as</span> pd
<span style="color: #b877db;">import</span> pymc <span style="color: #b877db;">as</span> pm
<span style="color: #b877db;">from</span> pymc.model.transform.conditioning <span style="color: #b877db;">import</span> do
<span style="color: #b877db;">import</span> arviz <span style="color: #b877db;">as</span> az
<span style="color: #b877db;">import</span> pytensor
<span style="color: #b877db;">import</span> pytensor.tensor <span style="color: #b877db;">as</span> pt
<span style="color: #b877db;">import</span> xarray <span style="color: #b877db;">as</span> xr
<span style="color: #b877db;">import</span> seaborn <span style="color: #b877db;">as</span> sns
<span style="color: #b877db;">from</span> tabulate <span style="color: #b877db;">import</span> tabulate
</pre>
</div>

<p>
We use the following versions of pymc and numpy:
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #b877db;">print</span>(np.__version__)
<span style="color: #b877db;">print</span>(pm.__version__)
</pre>
</div>

<pre class="example">
2.3.2
5.25.1
</pre>
</div>
<div id="outline-container-orgac2b94d" class="outline-3">
<h3 id="orgac2b94d">loading data</h3>
<div class="outline-text-3" id="text-orgac2b94d">
<p>
In order to have sufficient data for all our variables we analyze data from 2008-2018. We start with the data from 2008-2020. In the code below we make some further selections like positive population levels and a population that exceeds the number of deaths in a category. At the time of our analysis this narrows down the years to 2008-2018. The categories we are analyzing are indexed by age/gender/region/income as explained below.
</p>

<p>
We analyze mortality for ages 45-85. At lower ages, mortality is very close to zero; for ages above 85 the number of observations per age group drops rapidly.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>code-data</label><pre class="src src-jupyter-python" id="org6e17da8"><span style="color: #e95678;">low_year</span> = 2008
<span style="color: #e95678;">high_year</span> = 2020
<span style="color: #e95678;">low_age</span> = 45 
<span style="color: #e95678;">high_age</span> = 85
<span style="color: #e95678;">ds</span> = xr.open_dataset(<span style="color: #fab795;">'./data/oop_health_data.nc'</span>)
ds
</pre>
</div>

<pre class="example" id="org2225675">
&lt;xarray.Dataset&gt; Size: 22MB
Dimensions:                           (nuts2: 313, year: 11, sex: 2, age: 99)
Coordinates:
  * nuts2                             (nuts2) &lt;U4 5kB 'AT11' 'AT12' ... 'UKN0'
  * year                              (year) int64 88B 2008 2009 ... 2017 2018
  * sex                               (sex) &lt;U1 8B 'F' 'M'
  * age                               (age) float64 792B 1.0 2.0 ... 98.0 99.0
    country                           (nuts2) &lt;U14 18kB ...
Data variables:
    population                        (age, sex, year, nuts2) float64 5MB ...
    country_code                      (age, sex, year, nuts2) &lt;U2 5MB ...
    HF3_PC_CHE                        (age, sex, year, nuts2) float64 5MB ...
    deaths                            (age, sex, year, nuts2) float64 5MB ...
    percentage_material_deprivation   (year, nuts2) float64 28kB ...
    TOOEXP                            (year, nuts2) float64 28kB ...
    UNMET                             (year, nuts2) float64 28kB ...
    infant mortality                  (year, nuts2) float64 28kB ...
    number_physicians per inhabitant  (year, nuts2) float64 28kB ...
</pre>



<p>
Following python code generates the list <code>my_regions</code> where we have data on <code>population,deaths</code> and where we have at least one year (per region) with information on <code>UNMET</code> or where <code>UNMET</code> is not equal to zero for all years.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">my_regions = []
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">for r in np.unique(ds.nuts2.values):
</span><span style="color: #4e5059; font-style: italic;">#     </span><span style="color: #4e5059; font-style: italic;">A = np.sum(ds.where(ds.nuts2==r,drop=True).population.isnull().values)
</span><span style="color: #4e5059; font-style: italic;">#     </span><span style="color: #4e5059; font-style: italic;">B = np.sum(ds.where(ds.nuts2==r,drop=True).deaths.isnull().values)
</span><span style="color: #4e5059; font-style: italic;">#     </span><span style="color: #4e5059; font-style: italic;">C = np.sum(np.isnan(np.nanmean(ds.where(ds.nuts2==r,drop=True).UNMET.values,axis=0)))
</span><span style="color: #4e5059; font-style: italic;">#     </span><span style="color: #4e5059; font-style: italic;">D = np.sum(np.nanmean(ds.where(ds.nuts2==r,drop=True).UNMET.values,axis=0)==0)
</span><span style="color: #4e5059; font-style: italic;">#     </span><span style="color: #4e5059; font-style: italic;">if A + B + C + D == 0:
</span><span style="color: #4e5059; font-style: italic;">#         </span><span style="color: #4e5059; font-style: italic;">my_regions.append(r)
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">my_regions</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>code-selection</label><pre class="src src-jupyter-python" id="org07b906c"><span style="color: #e95678;">cohorts</span> = 30
<span style="color: #e95678;">age_matrix</span> = sliding_window_view(np.arange(low_age,high_age+1), cohorts)[:-1]
<span style="color: #e95678;">age_indices</span> = age_matrix-low_age
<span style="color: #e95678;">my_regions</span> = [<span style="color: #fab795;">'BG31'</span>, <span style="color: #fab795;">'BG32'</span>, <span style="color: #fab795;">'BG33'</span>, <span style="color: #fab795;">'BG34'</span>, <span style="color: #fab795;">'BG41'</span>, <span style="color: #fab795;">'BG42'</span>, <span style="color: #fab795;">'CH01'</span>, <span style="color: #fab795;">'CH02'</span>, <span style="color: #fab795;">'CH03'</span>, <span style="color: #fab795;">'CH04'</span>, <span style="color: #fab795;">'CH05'</span>, <span style="color: #fab795;">'CH06'</span>, <span style="color: #fab795;">'CH07'</span>, <span style="color: #fab795;">'DK01'</span>, <span style="color: #fab795;">'DK02'</span>, <span style="color: #fab795;">'DK03'</span>, <span style="color: #fab795;">'DK04'</span>, <span style="color: #fab795;">'DK05'</span>, <span style="color: #fab795;">'EL30'</span>, <span style="color: #fab795;">'EL41'</span>, <span style="color: #fab795;">'EL42'</span>, <span style="color: #fab795;">'EL43'</span>, <span style="color: #fab795;">'EL51'</span>, <span style="color: #fab795;">'EL52'</span>, <span style="color: #fab795;">'EL53'</span>, <span style="color: #fab795;">'EL54'</span>, <span style="color: #fab795;">'EL61'</span>, <span style="color: #fab795;">'EL62'</span>, <span style="color: #fab795;">'EL63'</span>, <span style="color: #fab795;">'EL64'</span>, <span style="color: #fab795;">'EL65'</span>, <span style="color: #fab795;">'FI1B'</span>, <span style="color: #fab795;">'FI1C'</span>, <span style="color: #fab795;">'FI1D'</span>, <span style="color: #fab795;">'HU11'</span>, <span style="color: #fab795;">'HU12'</span>, <span style="color: #fab795;">'HU21'</span>, <span style="color: #fab795;">'HU22'</span>, <span style="color: #fab795;">'HU23'</span>, <span style="color: #fab795;">'HU31'</span>, <span style="color: #fab795;">'HU32'</span>, <span style="color: #fab795;">'HU33'</span>, <span style="color: #fab795;">'LT01'</span>, <span style="color: #fab795;">'LT02'</span>, <span style="color: #fab795;">'NO01'</span>, <span style="color: #fab795;">'NO02'</span>, <span style="color: #fab795;">'NO03'</span>, <span style="color: #fab795;">'NO04'</span>, <span style="color: #fab795;">'NO05'</span>, <span style="color: #fab795;">'NO06'</span>, <span style="color: #fab795;">'NO07'</span>, <span style="color: #fab795;">'SE11'</span>, <span style="color: #fab795;">'SE12'</span>, <span style="color: #fab795;">'SE21'</span>, <span style="color: #fab795;">'SE22'</span>, <span style="color: #fab795;">'SE23'</span>, <span style="color: #fab795;">'SE31'</span>, <span style="color: #fab795;">'SE32'</span>, <span style="color: #fab795;">'SE33'</span>, <span style="color: #fab795;">'SI03'</span>, <span style="color: #fab795;">'SI04'</span>, <span style="color: #fab795;">'SK01'</span>, <span style="color: #fab795;">'SK02'</span>, <span style="color: #fab795;">'SK03'</span>, <span style="color: #fab795;">'SK04'</span>]
<span style="color: #e95678;">ds</span> = ds.where((low_age &lt;= ds.age) &amp; (ds.age &lt;= high_age) &amp;\
              (low_year &lt;= ds.year) &amp; (ds.year &lt;= high_year) &amp;\
              (ds.nuts2.isin(my_regions)) &amp;\
              (ds.country_code != <span style="color: #fab795;">""</span>) &amp;\
              (ds.population &gt; 1.0) &amp; (ds.population &gt; ds.deaths), drop=<span style="color: #f09383;">True</span>)
<span style="color: #e95678;">ds</span>[<span style="color: #fab795;">"TOOEXP"</span>] = ds[<span style="color: #fab795;">"TOOEXP"</span>].isel(age=0,sex=0)
<span style="color: #e95678;">ds</span>[<span style="color: #fab795;">"number_physicians per inhabitant"</span>] = ds[<span style="color: #fab795;">"number_physicians per inhabitant"</span>].isel(age=0,sex=0)
<span style="color: #e95678;">ds</span>[<span style="color: #fab795;">"infant mortality"</span>] = ds[<span style="color: #fab795;">"infant mortality"</span>].isel(age=0,sex=0)
<span style="color: #e95678;">ds</span>[<span style="color: #fab795;">"UNMET"</span>] = ds[<span style="color: #fab795;">"UNMET"</span>].isel(age=0,sex=0)
<span style="color: #e95678;">ds</span>[<span style="color: #fab795;">"UNMET_other"</span>] = ds[<span style="color: #fab795;">"UNMET"</span>]-ds[<span style="color: #fab795;">"TOOEXP"</span>]
<span style="color: #e95678;">ds</span>[<span style="color: #fab795;">"percentage_material_deprivation"</span>] = ds[<span style="color: #fab795;">"percentage_material_deprivation"</span>].isel(age=0,sex=0)
ds
</pre>
</div>

<pre class="example" id="org0957d62">
&lt;xarray.Dataset&gt; Size: 2MB
Dimensions:                           (age: 41, sex: 2, year: 11, nuts2: 65)
Coordinates:
  * nuts2                             (nuts2) &lt;U4 1kB 'BG31' 'BG32' ... 'SK04'
  * year                              (year) int64 88B 2008 2009 ... 2017 2018
  * sex                               (sex) &lt;U1 8B 'F' 'M'
  * age                               (age) float64 328B 45.0 46.0 ... 84.0 85.0
    country                           (nuts2) &lt;U14 4kB 'Bulgaria' ... 'Slovakia'
Data variables:
    population                        (age, sex, year, nuts2) float64 469kB 5...
    country_code                      (age, sex, year, nuts2) object 469kB 'B...
    HF3_PC_CHE                        (age, sex, year, nuts2) float64 469kB n...
    deaths                            (age, sex, year, nuts2) float64 469kB 1...
    percentage_material_deprivation   (year, nuts2) float64 6kB nan nan ... 10.0
    TOOEXP                            (year, nuts2) float64 6kB 12.8 ... 0.4
    UNMET                             (year, nuts2) float64 6kB 27.4 ... 6.5
    infant mortality                  (year, nuts2) float64 6kB 9.1 8.0 ... 8.8
    number_physicians per inhabitant  (year, nuts2) float64 6kB 373.1 ... 344.6
    UNMET_other                       (year, nuts2) float64 6kB 14.6 9.5 ... 6.1
</pre>


<p>
The <code>age_matrix</code> defined above has the following format. In our first year, 2008, we start with people aged 45-74. We follow these age-cohorts over time till 2018 when they are aged 55-84. We summarize this in the paper in Table <a href="#org6103c20">1</a>.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #b877db;">print</span>(tabulate(age_matrix, tablefmt=<span style="color: #fab795;">"orgtbl"</span>))
</pre>
</div>

<pre class="example" id="orge5357a7">
| 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 |
| 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 |
| 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 |
| 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 |
| 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 |
| 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 |
| 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 |
| 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 |
| 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 |
| 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 |
| 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 |
</pre>






<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>code-matrices</label><pre class="src src-jupyter-python" id="org0ade70d"><span style="color: #e95678;">country</span> = ds.country.values
<span style="color: #e95678;">n_regions</span> = ds.nuts2.values.shape[0] <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">number of regions 
</span><span style="color: #e95678;">n_countries</span> = <span style="color: #b877db;">len</span>(np.unique(ds.country.values)) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">number of countries
</span><span style="color: #e95678;">n_ages</span> = ds.age.values.shape[0] <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">number of ages
</span>
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">Mapping of regions to countries
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">Example: regions 0, 1 -&gt; country 0; regions 2, 3 -&gt; country 1; regions 4, 5 -&gt; country 2
</span><span style="color: #e95678;">region_to_country</span> = pd.factorize(country)[0]

<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">Create the matrix (countries x regions)
</span><span style="color: #e95678;">country_region_matrix_01</span> = np.zeros((n_countries, n_regions)) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">0-1 matrix with a 1 at position cr if region r belongs to country c
</span><span style="color: #b877db;">for</span> r,c <span style="color: #b877db;">in</span> <span style="color: #b877db;">enumerate</span>(region_to_country):
     <span style="color: #e95678;">country_region_matrix_01</span>[<span style="color: #e95678;">c</span>, <span style="color: #e95678;">r</span>] = 1

<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">Normalize rows to compute averages per country (across regions)
</span><span style="color: #e95678;">country_region_matrix</span> = country_region_matrix_01 / country_region_matrix_01.<span style="color: #b877db;">sum</span>(axis=1, keepdims=<span style="color: #f09383;">True</span>)

</pre>
</div>

<p>
For some country/year combinations we see in the data that <code>OOP</code> (<code>HF3_PC_CHE</code>) equals zero. As in no European country healthcare is completely free, we interpret 0 as a missing observation. With <code>xarray</code> we can turn a 0 into <code>nan</code> by setting <code>da = da.where(da != 0)</code> where <code>da</code> denotes the data array. This is the code we use below for <code>OOP, infant mortality</code> and <code>Unmet</code>. No infant mortality in a region or no unmet medical needs is also highly unlikely; hence a zero value is turned into <code>nan</code>. If <code>Unmet</code> equals zero, the same is true for <code>UNMET_other</code> and <code>TooExp</code> because <code>UNMET = TooExp + UNMET_other</code>.
</p>

<p>
OOP does not vary with age or gender and hence we can take the average across dimensions <code>(0,1)</code> without losing information. The result is a variable varying over years and across regions. But out-of-pocket varies by country (not by region within a country) and hence we multiply <code>OOP</code> with the <code>country_region_matrix</code> (transformed). This makes sure that <code>OOP_c</code> varies by year and country.
</p>

<p>
In our empirical analysis we use the standardized version of the number of physicians per 100k inhabitants. Variables like OOP, material deprivation and unmet medical needs are turned from percentages into fractions for the analysis. We also turn infant mortality (per 1000 life-births) into a variable between 0 and 1 by dividing it by 100 (effectively making it infant mortality per 100k life-births).
</p>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>code-variables</label><pre class="src src-jupyter-python" id="orgde6fdc3"><span style="color: #b877db;">def</span> <span style="color: #87ceeb;">standardize</span>(x):
    <span style="color: #b877db;">return</span> (x-np.nanmean(x))/np.nanstd(x)
<span style="color: #e95678;">Population</span> = ds.population.values.astype(<span style="color: #b877db;">int</span>)
<span style="color: #e95678;">physicians</span> = standardize(ds[<span style="color: #fab795;">'number_physicians per inhabitant'</span>].values)
<span style="color: #e95678;">OOP</span> = ds.HF3_PC_CHE.where(ds.HF3_PC_CHE!=0)/100.0  <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">replaces OOP equal to 0 with nan
</span><span style="color: #e95678;">m_infant</span> = ds[<span style="color: #fab795;">'infant mortality'</span>].where(ds[<span style="color: #fab795;">'infant mortality'</span>]!=0)/100.0  <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">replaces infant mortality equal to 0 with nan
</span><span style="color: #e95678;">OOP_c</span> = np.dot(OOP.mean(axis=(0,1)),country_region_matrix.T)
<span style="color: #e95678;">M</span> = ds.deaths.values.astype(<span style="color: #b877db;">int</span>)
<span style="color: #e95678;">Deprivation</span> = ds.percentage_material_deprivation/100.0 
<span style="color: #e95678;">Unmet</span> = ds.UNMET.where(ds.UNMET!=0)/100.0  <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">replaces UNMET equal to 0 with nan
</span><span style="color: #e95678;">TooExp</span> = ds.TOOEXP.where(ds.UNMET!=0)/100.0
<span style="color: #e95678;">Unmet_o</span> = ds.UNMET_other.where(ds.UNMET!=0)/100.0 
<span style="color: #e95678;">U_log_odds</span> = np.log((Unmet)/(1-Unmet))
<span style="color: #e95678;">U_o_log_odds</span> = np.log((Unmet_o)/(1-Unmet_o))
</pre>
</div>
</div>
</div>
<div id="outline-container-org5306fd1" class="outline-3">
<h3 id="org5306fd1">creating cohort data</h3>
<div class="outline-text-3" id="text-org5306fd1">
<p>
We analyze population and mortality in tensor-format. The dimensions of the tensors <code>P_cohort, M_cohort</code> are calendar year, cohort size (first row in Table <a href="#org6103c20">1</a>), gender and region. 
</p>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>code-cohorts</label><pre class="src src-jupyter-python" id="org5e956ce"><span style="color: #e95678;">c_dim</span>, <span style="color: #e95678;">g_dim</span>, <span style="color: #e95678;">t_dim</span>, <span style="color: #e95678;">r_dim</span> = cohorts, 2, <span style="color: #b877db;">len</span>(ds.year), n_regions
<span style="color: #e95678;">n_dim</span> = n_countries
<span style="color: #e95678;">P_cohort</span> = np.zeros((t_dim, c_dim, g_dim, r_dim))
<span style="color: #e95678;">M_cohort</span> = np.zeros((t_dim, c_dim, g_dim, r_dim))

<span style="color: #b877db;">for</span> offset <span style="color: #b877db;">in</span> <span style="color: #b877db;">range</span>(c_dim):
  <span style="color: #b877db;">for</span> g <span style="color: #b877db;">in</span> <span style="color: #b877db;">range</span>(g_dim):
     <span style="color: #b877db;">for</span> r <span style="color: #b877db;">in</span> <span style="color: #b877db;">range</span>(r_dim):
        <span style="color: #e95678;">P_cohort</span>[:,<span style="color: #e95678;">offset</span>,<span style="color: #e95678;">g</span>,<span style="color: #e95678;">r</span>] = np.diagonal(Population, axis1=0, axis2=2, offset=-offset)[g,r,:]
        <span style="color: #e95678;">M_cohort</span>[:,<span style="color: #e95678;">offset</span>,<span style="color: #e95678;">g</span>,<span style="color: #e95678;">r</span>] = np.diagonal(M, axis1=0, axis2=2, offset=-offset)[g,r,:]
</pre>
</div>

<p>
We use the following moments to specify our priors for missing values in these variables. To deal with missing values in <code>Deprivation</code> we model it as a distribution from which we draw missing values. Such a distribution cannot have a standard deviation of zero and hence we add a small number to the standard deviation to avoid this. See section for a discussion of missing values.
</p>

<p>
There are four regions in Norway on which we have no information at all about the number of physicians. For these regions we set <code>mean_physician</code> equal to the average number of physicians in Norway and <code>std_physician</code> equal to the average standard deviation for Norway.
</p>

<p>
Finally, to define the log-odds of mortality (number of deaths <code>M</code> over population <code>P</code>) we add 1 to <code>M</code> to avoid taking the logarithm of zero.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>code-moments</label><pre class="src src-jupyter-python" id="orgc16d423"><span style="color: #e95678;">mean_depr</span> = Deprivation.mean(axis=(0)).values
<span style="color: #e95678;">std_depr</span> = Deprivation.std(axis=(0)).values + 0.0001
<span style="color: #e95678;">mean_oop_c</span> = np.nanmean(OOP_c,axis=0)
<span style="color: #e95678;">std_oop_c</span> = np.nanstd(OOP_c,axis=0)
<span style="color: #e95678;">mean_m_infant</span> = np.nanmean(m_infant,axis=0)
<span style="color: #e95678;">std_m_infant</span> = np.nanstd(m_infant,axis=0)
<span style="color: #e95678;">mean_physician</span> = np.nanmean(physicians,axis=0) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">mean over years 
</span><span style="color: #e95678;">std_physician</span> = np.nanstd(physicians,axis=0)   <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">std over years
</span><span style="color: #e95678;">norway</span> = [<span style="color: #fab795;">'NO'</span> <span style="color: #b877db;">in</span> r <span style="color: #b877db;">for</span> r <span style="color: #b877db;">in</span> ds.nuts2.values]
<span style="color: #e95678;">mean_norway</span> = np.nanmean(mean_physician[norway])
<span style="color: #e95678;">mean_physician</span> = np.nan_to_num(mean_physician,nan=mean_norway)
<span style="color: #e95678;">std_norway</span> = np.nanmean(std_physician[norway])
<span style="color: #e95678;">std_physician</span> = np.nan_to_num(std_physician,nan=std_norway)
<span style="color: #e95678;">log_odds_mort</span> = np.log(((1+M)/Population)/(1-((1+M)/Population)))
<span style="color: #e95678;">mort_c</span> = np.log(np.tensordot(((1+M_cohort)/P_cohort), country_region_matrix.T, axes=([3],[0]))/(1- np.tensordot(((1+M_cohort)/P_cohort),\
                                              country_region_matrix.T, axes=([3],[0])))) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">varies by age, cohorts, gender, country
</span><span style="color: #e95678;">gender_effect_&#960;</span> = (mort_c.mean(axis=(0,1,3))-mort_c.mean(axis=(0,1,2,3))) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">varies by gender
</span><span style="color: #e95678;">country_effect_&#960;</span> = (mort_c.mean(axis=(0,1,2))-mort_c.mean(axis=(0,1,2,3))) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">varies by country</span>
</pre>
</div>

<pre class="example">
/var/folders/g3/0hgyvgbn6x3105r_s_rgnrx40000gn/T/ipykernel_11128/260719900.py:7: RuntimeWarning: Mean of empty slice
  mean_physician = np.nanmean(physicians,axis=0) # mean over years
/Users/janboone/anaconda3/envs/pymc_env/lib/python3.12/site-packages/numpy/lib/nanfunctions.py:1879: RuntimeWarning: Degrees of freedom &lt;= 0 for slice.
  var = nanvar(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
</pre>
</div>
</div>
</div>
<div id="outline-container-org8f87a13" class="outline-2">
<h2 id="org8f87a13"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Healthcare policy decisions often unfold over long time horizons, yet much of the empirical evidence on health insurance reform focuses on short-run outcomes. In particular, studies of demand-side cost-sharing typically rely on difference-in-differences (DiD) designs that estimate health effects over a narrow window around the implementation of a policy. While these approaches yield credible short-run causal estimates, they are poorly suited to capturing the cumulative, long-term consequences of forgone care, especially when mortality is used as the outcome of interest.
</p>

<p>
This paper takes a dynamic approach to analyzing the health effects of cost-sharing. We develop and estimate a structural model of health transitions, mortality, and insurance generosity using regional-level Eurostat data from 11 European countries over the 2008–2018 period. Our framework follows cohorts by age, gender, region, and income, distinguishing between individuals in high and low health states, and modeling transitions using a Markov process. Importantly, we allow treatment probabilities &#x2013;and thus recovery rates&#x2013; to depend on out-of-pocket spending and unmet medical needs. This enables us to quantify both short- and long-run effects of cost-sharing on mortality.
</p>

<p>
We show that increases in out-of-pocket costs lead to reductions in health, disproportionately affecting low-income populations. Crucially, the dynamic effects are an order of magnitude larger than static DiD estimates would suggest. Our results highlight a key policy evaluation trade-off: methods that yield clean identification in the short run may vastly understate the true long-run burden of cost-sharing, particularly for the most vulnerable groups.
</p>

<p>
Our estimated model fits the data well and replicates a number of stylized facts. Women have higher health status than men and people on high income higher than people in poverty. The probability of falling ill increases with age. Although there is uncertainty about the parameter estimates, there is an unambiguous ordering of countries in terms of expected qaly&rsquo;s for 45 year olds; over the 2008-2018 period Switzerland has the highest expected qaly&rsquo;s and Hungary, Bulgaria and Lithuania the lowest.
</p>


<p>
We contribute to the literature on the health effects of demand-side cost-sharing by emphasizing dynamic consequences and the disproportionate impact on low-income individuals.
</p>

<p>
Several studies have established causal effects of health insurance on mortality using individual-level U.S. data and policy variation from the Affordable Care Act (ACA). For instance, the Medicaid expansions have been shown to reduce mortality using DiD approaches (<a href="#citeproc_bib_item_1">Borgschulte and Vogler 2020</a>; <a href="#citeproc_bib_item_7">Miller, Johnson, and Wherry 2021</a>). However, these studies focus on short-run effects &#x2013;typically two to four years post-reform&#x2013; and do not capture long-run health dynamics. 
</p>

<p>
Other studies also link higher out-of-pocket (oop) costs to reduced healthcare use and higher mortality (<a href="#citeproc_bib_item_3">Chandra, Flack, and Obermeyer 2021</a>), but again only in a static or within-year framework. Similarly, Goldin, Lurie, and McCubbin (<a href="#citeproc_bib_item_5">2020</a>) find mortality effects in an RCT encouraging ACA compliance, but focus on a two-year window and individuals aged 45–64.
</p>

<p>
Our contribution differs in three main ways. First, we use European data, where insurance systems are more homogeneous and nearly universal &#x2013;over 99% of the population is typically covered (see the entry on Health insurance coverage with Government/compulsory health insurance from the <a href="https://data-explorer.oecd.org/?lc=en">OECD Data Explorer</a>). This allows for a clearer link between policy variation and health outcomes at the population level.
</p>

<p>
Second, we estimate a dynamic structural model tracking health status transitions over time. This enables us to compare long-run effects of cost-sharing with short-run DiD-style estimates. Our results show dynamic effects for low-income groups are magnitudes larger than static ones. We illustrate this by using the estimation method in Finkelstein and McKnight (<a href="#citeproc_bib_item_4">2008</a>) to explain the difference in detail.
</p>

<p>
Third, by using EU-SILC data on unmet medical needs, we explore a concrete mechanism: individuals forgoing care due to cost, especially at low incomes. This aligns with previous findings on liquidity constraints and care deferral (<a href="#citeproc_bib_item_6">Gross, Layton, and Prinz 2020</a>; <a href="#citeproc_bib_item_8">Nyman 2003</a>). While high-income individuals may also forgo treatment, it is less driven by financial barriers (<a href="#citeproc_bib_item_2">Brot-Goldberg et al. 2017</a>; <a href="#citeproc_bib_item_3">Chandra, Flack, and Obermeyer 2021</a>). Our results reflect this, showing much smaller effects in that group.
</p>

<p>
The next section presents a dynamic model of health status and mortality. Then we describe the Eurostat data that we use. We explain the empirical model that we estimate. Estimation results are presented and we conclude with a discussion of the policy implications. The appendix contains more details on our data and estimation. The <a href="https://janboone.github.io/dynamic-effects-of-health-insurance-reform/index.html">online appendix</a> is the html version of this paper which includes &#x2013;per section&#x2013; the python code that is used in each section&rsquo;s analysis.<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> This is an advantage of using data at the regional level. The repository contains the python code that gets the data from Eurostat so that each step of this analysis can be replicated.
</p>
</div>
</div>
<div id="outline-container-org0908337" class="outline-2">
<h2 id="org0908337"><span class="section-number-2">2.</span> Theory</h2>
<div class="outline-text-2" id="text-2">
<p>

</p>

<p>
The idea of our dynamic model is to follow a cohort aged \(a\) at time \(t\) across calendar years to age \(a+1\) and year \(t+1\). We capture this dynamic with a straightforward Markov model. The model that we estimate is illustrated in Figure <a href="#orgf7f771a">1</a>. We follow individuals from age 45 to age 85. Let&rsquo;s denote the age at which we start following an individual by \(a=0\) at time \(t=0\). If this agent is healthy, there is a probability \(\pi\) that the agent falls ill and moves to state ill at age \(a=1\) in period \(t=1\). With probability \(1-\pi\) the agent stays healthy also at age \(a=1\). For an agent in the unhealthy state, there is a probability \(\sigma\) that she is cured and becomes healthy at age \(a=1\). With probability \(\delta\) she dies and with probability \(1-\sigma-\delta\) she remains in the unhealthy state at \(a=1\). Finally, death is an absorbing state.
</p>



<div id="orgf7f771a" class="figure">
<p><img src="./figures/markov_chain.png" alt="markov_chain.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Markov chain model</p>
</div>

<p>
Instead of deriving the steady state outcome of the model, we estimate parameters using the underlying difference equation. Focusing just on age for the moment to ease notation, the model implies the following difference equation. Let \(\iota_a\) denote the fraction of people aged \(a\) who are ill and \(1-\iota_a\) the fraction who are healthy, then \(\iota_a\) evolves over age (and time) as:
</p>
\begin{equation}
\label{org628d60c}
\iota_{a+1} = ((1-\sigma-\delta) \iota_a + \pi_a (1-\iota_a))/(1-\delta \iota_{a})
\end{equation}
<p>
and \(\delta \iota_a\) people die at age \(a\). In words, the fraction of people ill aged \(a+1\) equals the fraction ill aged \(a\) who do neither recover to the healthy state nor die plus the fraction of healthy people who fall ill. We normalize by \(1-\delta \iota_a\) to ensure that the fractions ill and healthy add up to one.
</p>

<p>
We differentiate the fraction ill, \(\iota_a\), by region/year/gender/income. If we add all the sub/superscripts we get \(\iota_{atr}^{ij}\) for age \(a\) in year \(t\) and region \(r\) among gender \(i \in \{f,m\}\) and low/high income \(j \in \{l,h\}\). Let \(\alpha_{tr}\) denote the fraction of people on low income in region \(r\) and year \(t\) which is available in our data. We observe in our data mortality \(\mu_{atr}^{i}\), the fraction of females/males \(i\) who die at age \(a\) in year \(t\) in region \(r\). In terms of our model this is given by
</p>
\begin{equation}
\label{org2b148dd}
\mu_{atr}^i = \alpha_{tr} \delta \iota_{atr}^{il} + (1-\alpha_{tr}) \delta \iota_{atr}^{ih}
\end{equation}

<p>
As we do not observe \(\iota\) directly in our data, we have to estimate the starting points of the fraction of people initially ill, \(\iota_0\), in order to solve the difference equations over time. Our estimates of \(\iota_0\) vary by age/gender/region/income. The reason \(\iota_0\) varies by age is illustrated in Table <a href="#org6103c20">1</a>. Differentiated by gender/region/income we follow the cohorts aged 45-74 over time until they are aged 55-84. The data section below motivates this choice. Hence we estimate the initial values \(\iota_0\) for the ages 45-74 in the year 2008. Then we apply equation \eqref{org628d60c} to determine the development of \(\iota_a\) over time as cohorts get older.
</p>

<table id="org6103c20" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> We follow cohorts aged 45-74 over time from 2008 until they are 55-84 in 2018.</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">year</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-left">age</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">2008</td>
<td class="org-right">45</td>
<td class="org-right">46</td>
<td class="org-right">47</td>
<td class="org-right">48</td>
<td class="org-left">&#x2026;</td>
<td class="org-right">68</td>
<td class="org-right">69</td>
<td class="org-right">70</td>
<td class="org-right">71</td>
<td class="org-right">72</td>
<td class="org-right">73</td>
<td class="org-right">74</td>
</tr>

<tr>
<td class="org-right">2009</td>
<td class="org-right">46</td>
<td class="org-right">47</td>
<td class="org-right">48</td>
<td class="org-right">49</td>
<td class="org-left">&#x2026;</td>
<td class="org-right">69</td>
<td class="org-right">70</td>
<td class="org-right">71</td>
<td class="org-right">72</td>
<td class="org-right">73</td>
<td class="org-right">74</td>
<td class="org-right">75</td>
</tr>

<tr>
<td class="org-right">2010</td>
<td class="org-right">47</td>
<td class="org-right">48</td>
<td class="org-right">49</td>
<td class="org-right">50</td>
<td class="org-left">&#x2026;</td>
<td class="org-right">70</td>
<td class="org-right">71</td>
<td class="org-right">72</td>
<td class="org-right">73</td>
<td class="org-right">74</td>
<td class="org-right">75</td>
<td class="org-right">76</td>
</tr>

<tr>
<td class="org-right">2011</td>
<td class="org-right">48</td>
<td class="org-right">49</td>
<td class="org-right">50</td>
<td class="org-right">51</td>
<td class="org-left">&#x2026;</td>
<td class="org-right">71</td>
<td class="org-right">72</td>
<td class="org-right">73</td>
<td class="org-right">74</td>
<td class="org-right">75</td>
<td class="org-right">76</td>
<td class="org-right">77</td>
</tr>

<tr>
<td class="org-right">2012</td>
<td class="org-right">49</td>
<td class="org-right">50</td>
<td class="org-right">51</td>
<td class="org-right">52</td>
<td class="org-left">&#x2026;</td>
<td class="org-right">72</td>
<td class="org-right">73</td>
<td class="org-right">74</td>
<td class="org-right">75</td>
<td class="org-right">76</td>
<td class="org-right">77</td>
<td class="org-right">78</td>
</tr>

<tr>
<td class="org-right">2013</td>
<td class="org-right">50</td>
<td class="org-right">51</td>
<td class="org-right">52</td>
<td class="org-right">53</td>
<td class="org-left">&#x2026;</td>
<td class="org-right">73</td>
<td class="org-right">74</td>
<td class="org-right">75</td>
<td class="org-right">76</td>
<td class="org-right">77</td>
<td class="org-right">78</td>
<td class="org-right">79</td>
</tr>

<tr>
<td class="org-right">2014</td>
<td class="org-right">51</td>
<td class="org-right">52</td>
<td class="org-right">53</td>
<td class="org-right">54</td>
<td class="org-left">&#x2026;</td>
<td class="org-right">74</td>
<td class="org-right">75</td>
<td class="org-right">76</td>
<td class="org-right">77</td>
<td class="org-right">78</td>
<td class="org-right">79</td>
<td class="org-right">80</td>
</tr>

<tr>
<td class="org-right">2015</td>
<td class="org-right">52</td>
<td class="org-right">53</td>
<td class="org-right">54</td>
<td class="org-right">55</td>
<td class="org-left">&#x2026;</td>
<td class="org-right">75</td>
<td class="org-right">76</td>
<td class="org-right">77</td>
<td class="org-right">78</td>
<td class="org-right">79</td>
<td class="org-right">80</td>
<td class="org-right">81</td>
</tr>

<tr>
<td class="org-right">2016</td>
<td class="org-right">53</td>
<td class="org-right">54</td>
<td class="org-right">55</td>
<td class="org-right">56</td>
<td class="org-left">&#x2026;</td>
<td class="org-right">76</td>
<td class="org-right">77</td>
<td class="org-right">78</td>
<td class="org-right">79</td>
<td class="org-right">80</td>
<td class="org-right">81</td>
<td class="org-right">82</td>
</tr>

<tr>
<td class="org-right">2017</td>
<td class="org-right">54</td>
<td class="org-right">55</td>
<td class="org-right">56</td>
<td class="org-right">57</td>
<td class="org-left">&#x2026;</td>
<td class="org-right">77</td>
<td class="org-right">78</td>
<td class="org-right">79</td>
<td class="org-right">80</td>
<td class="org-right">81</td>
<td class="org-right">82</td>
<td class="org-right">83</td>
</tr>

<tr>
<td class="org-right">2018</td>
<td class="org-right">55</td>
<td class="org-right">56</td>
<td class="org-right">57</td>
<td class="org-right">58</td>
<td class="org-left">&#x2026;</td>
<td class="org-right">78</td>
<td class="org-right">79</td>
<td class="org-right">80</td>
<td class="org-right">81</td>
<td class="org-right">82</td>
<td class="org-right">83</td>
<td class="org-right">84</td>
</tr>
</tbody>
</table>


<p>
The remainder of the section explains how \(\pi,\delta,\sigma\) vary with age/year/gender/region/income. First, the probability of falling ill \(\pi\) varies by age/gender/country/income. We know that older people tend to be less healthy than young people, women tend to live longer than men, longevity varies by country and people on low income tend to have lower health status than people on high income. We allow \(\pi\) to vary along these dimensions to capture these stylized facts. 
</p>

<p>
Second, once people are in state &ldquo;ill&rdquo; we assume that their probability of death \(\delta\) is the same across age/gender/income. We do allow \(\delta_c\) to vary by country as some healthcare systems may be better in prolonging life for the ill than systems in other countries.
</p>

<p>
A final source of variation is the probability \(\sigma\) with which people recover to full health. This probability \(\sigma\) is determined by the probability of treatment and the quality of treatment conditional on being treated. We have data on unmet medical needs. Reasons for unmet medical needs, that is reasons why people forgo treatment include waiting lists, hospital too far away, afraid of treatment. The motivation that we focus on is that the treatment is skipped because it is too expensive. Let \(\upsilon \in [0,1]\) denote the fraction of people who have unmet medical needs. We write this as the sum of the fraction of people who indicate that treatment is too expensive, \(\tau\), and the fraction of people who give other reasons, \(\upsilon_0\).
</p>
\begin{equation}
\label{org4e7330a}
\upsilon = \upsilon_0 + \tau
\end{equation}
<p>
We expect that \(\tau\) is increasing in the fraction of healthcare expenditures that people pay out-of-pocket, \(oop\), where \(oop\) is measured as expenditure paid out-of-pocket over total healthcare expenditure. We interpret this as capturing the generosity of a country&rsquo;s health insurance system. We use a linear approximation of this relation:
</p>
\begin{equation}
\label{org1c258d1}
\tau = \zeta oop
\end{equation}
<p>
If healthcare is completely free at point-of-service, \(oop=0\) and \(\tau=0\): with free healthcare, no one forgoes treatment because it is too expensive. At the other extreme, no health insurance at all: everything is paid out-of-pocket: \(oop=1\). Then a fraction \(\zeta \in [0,1]\) will indicate they forgo treatment because it is too expensive.
</p>

<p>
We allow \(\zeta\) to depend on income with \(\zeta^l \geq \zeta^h\). We expect people on low income to react more strongly to an increase in \(oop\) than people on high income. Also people on low income are more likely to avoid treatment for other reasons: \(\upsilon_0^l \geq u_0^h\). To illustrate, people on low income may be less skilled, say, in navigating waiting lists or find it more difficult to travel to a hospital that is further away (or even abroad).
</p>

<p>
If someone gets treatment, the probability of recovering to full health is given by \(\lambda\). Hence, we write the probability of recovery \(\sigma\) as
</p>
\begin{equation}
\label{org6e9dd24}
\sigma = \sigma_0 + \lambda (1-\upsilon)
\end{equation}
<p>
where \(\sigma_0\) is the probability that someone recovers without treatment. The parameter \(\lambda\) captures the quality of care which we allow to vary by region and year in ways explained below.
</p>

<p>
We consider two applications of our model. First, as a summary statistic of health we calculate the expected quality adjusted life-years (qaly&rsquo;s) of 45 year olds till they are 85. We normalize the value of a life-year in full health to 1.0 and set the qaly for a year being ill equal to \(\theta \in \langle 0, 1]\). The value of a &ldquo;life-year when dead&rdquo; is normalized to 0.0. To make this qaly calculation, we keep track of the size of the groups healthy and ill as follows:
</p>
\begin{equation}
\label{org8fa3ecb}
N^{healthy}_{a+1} = (1-\pi_a) N^{healthy}_a + \sigma N^{ill}_{a}
\end{equation}
<p>
and
</p>
\begin{equation}
\label{org757095d}
N^{ill}_{a+1} = \pi_a N^{healthy}_{a} + (1-\sigma-\delta) N^{ill}_{a}
\end{equation}
<p>
where we start with 45 year olds at \(a=0\) and calculate up to age \(A\) (corresponding to 85 year olds). In contrast to equation \eqref{org628d60c} we do not normalize \(N^{ill}_a + N^{healthy}_a = 1\); indeed, the point is that we lose life-years as age increases. As above \(N^{healthy}_{a},N^{ill}_{a},\pi_a,\sigma,\delta\) vary with gender/region/income.
</p>

<p>
We then calculate expected quality adjusted life-years from age 1 to \(A\) as the undiscounted sum of qaly&rsquo;s:<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>
</p>
\begin{equation}
\label{org5faadf5}
Q = \sum_{a=1}^{A} N^{healthy}_a + \theta N^{ill}_{a}
\end{equation}

<p>
Second, we consider the effect on qaly&rsquo;s of an increase in demand-side cost-sharing \(\Delta oop > 0\). For this, we calculate qaly&rsquo;s in the baseline outcome, \(Q_0\) and compare it with the outcome where the fraction of people with unmet medical needs increases with \(\Delta \upsilon = \zeta \Delta oop\). We denote the qaly&rsquo;s in this outcome by \(Q_1\). The loss of qaly&rsquo;s  due to increased demand-side cost-sharing is given by:
</p>
\begin{equation}
\label{org3970a1a}
\Delta Q = Q_0 - Q_1
\end{equation}
<p>
In words, suppose there was a reform in year \(t=0\) which increased \(oop\). After the reform we follow the cohort aged \(a=0\) over time till age \(a=A\) and calculate their qaly&rsquo;s, \(Q_1\). We compare these qaly&rsquo;s with the counterfactual where \(oop\) was not changed, \(Q_0\). We denote this the dynamic comparison.
</p>

<p>
We compare this dynamic analysis with the following static one. Instead of following an age cohort over \(A\) calendar years, we consider \(A\) ages one period after the reform and denote their qaly&rsquo;s by \(\tilde Q_1\). That is, the equation for \(\tilde Q\) is comparable to \eqref{org5faadf5} except that in equation \eqref{org5faadf5} both age \(a\) and calendar year \(t\) vary over the summation. With \(\tilde Q\) calendar year is fixed at \(t=1\) (with the reform happening in calendar year \(t=0\)). We then compare \(\tilde Q_1\) with the qaly&rsquo;s these \(A\) age groups would have received under the counterfactual where \(oop\) is unchanged, \(\tilde Q_0\).
</p>

<p>
To illustrate with Table <a href="#org6103c20">1</a>: we start with ages 45-74 at \(t=0\). We have the reform and calculate \(\tilde Q_1\) for the second row in the table (ages 46-75). Then we compare this to qaly&rsquo;s for the second row under the counterfactual of no change in \(oop\). We argue that this captures the estimate made by an event study like a DiD analysis, say where the reform was introduced in one region but not in another region. The DiD approach would then control for year fixed effects.
</p>

<p>
This type of analysis can identify the causal effect convincingly but is usually applied for a couple of years only. For instance, because in later years the reform is introduced in other regions as well. Or because over time other factors may change causing a bias in the estimates based on the comparison of the regions.
</p>

<p>
Theoretically, it is plausible that the dynamic estimate exceeds the static one. In a model where stocks (of healthy and ill) determine the state of the system and its development over time, ignoring these dynamic effects is likely to cause an under-estimation of the effect on qaly&rsquo;s or mortality. With our estimated model we can quantify the difference between the static and dynamic estimates.
</p>
</div>
<div id="outline-container-org8695b2c" class="outline-3">
<h3 id="org8695b2c"><span class="section-number-3">2.1.</span> Markov chain graph&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>Graphviz code block</label><pre class="src src-dot">digraph ER {
        fontname="Helvetica,Arial,sans-serif"
        node [fontname="Helvetica,Arial,sans-serif" fontsize="16"]
        edge [fontname="Helvetica,Arial,sans-serif" fontsize="16"]
        layout=sfdp
        node [shape=ellipse]; a; b; death;

        a  [label="healthy"]
        b  [label="ill"]

        a -&gt; b [label="&amp;pi;\n",len=0.500];
        b -&gt; a [label="  &amp;sigma;",len=0.500];
        b -&gt; death [label="&amp;delta;\n",len=0.00];
}
</pre>
</div>


<div id="org2bd7d20" class="figure">
<p><img src="./figures/markov_chain.png" alt="markov_chain.png" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcc21baa" class="outline-2">
<h2 id="orgcc21baa"><span class="section-number-2">3.</span> Data</h2>
<div class="outline-text-2" id="text-3">
<p>
The data that we use is from <a href="https://ec.europa.eu/eurostat/web/regions/database">Eurostat&rsquo;s regional database</a> and provides for NUTS 2 regions population size and number of deaths per age/gender category. In principle, we have data on 11 countries and 65 regions for the 11 years 2008-2018 and ages 45-84 for women and men. The years 2008-2018 were chosen  because, at the time of the analysis, for most variables and regions data was available from 2008 onward till 2018. The age range was chosen with the idea that mortality starts to increase from 45 years onward and number of observations per region drop significantly from age 85 onward. Finally, NUTS 2 regions were selected where there was at least one observation for unmet medical needs over the years and where the number of deaths during the year does not exceed the population size at the start of the year.
</p>

<p>
Table <a href="#orge5ea27f">2</a> shows the summary statistics for our variables. We briefly discuss the main variables, the appendix provides more detail. We have more than 40k observations for population and deaths per age/gender/year/region category.<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup> We have missing observations and explain below how we deal with these in our Bayesian setting.
</p>

<p>
The average population size per region-age-gender category is about 6000 and the average number of deaths 90. Median population size per category equals 5300 and median number of deaths 62. In our data, the percentage of people dying in a NUTS 2/year/age/gender category (<code>mortality</code>) equals 2% on average with a maximum of 17.3% for some region and age combination. The material deprivation measure (denoted <code>deprivation</code>) comes from the EU statistics on income and living conditions (<a href="https://ec.europa.eu/eurostat/statistics-explained/index.php?title=Glossary:EU_statistics_on_income_and_living_conditions_(EU-SILC)">EU-SILC</a>) survey. It refers to the enforced inability to pay unexpected expenses, afford adequate heating of the home, durable goods like a washing machine etc. This variable captures the idea that people may feel forced to forgo (valuable) treatment because it is too expensive.<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup> The mean deprivation rate across regions and years equals 10%. Some regions have (almost) no people in deprivation, while in others 55% of people live in deprivation. The median rate is around 3%.
</p>

<p>
Also from the EU-SILC survey, we use the variable capturing unmet medical needs because the forgone treatment was too expensive (<code>too exp</code>). The variable <code>unmet</code> measures percentage of people in need of healthcare that postpone or forgo treatment because it is either too expensive, the hospital is too far away, there is a waiting list for the treatment, the patient hopes that symptoms will disappear without treatment, the patient is afraid of treatment or has no time to visit a physician. The mean fraction of people forgoing treatment because it is too expensive equals 1.5%, while the mean fraction of people with unmet medical needs (because it is too expensive or other reasons) equals 6.5%. In some regions the fraction of people forgoing treatment because it is too expensive goes up to almost 20% and the fraction of people with unmet medical needs to almost 30%.
</p>

<p>
For the model application considering the effect of demand-side cost-sharing on health and mortality, healthcare quality could be a collider. Indeed, if government resources are reduced, there could be both an increase in out-of-pocket payments and a reduction in healthcare quality (by reducing investments in technology and/or reducing the number of physicians). This reduction in quality would also affect health and mortality thereby confounding the healthcare demand effect of out-of-pocket spending. We use two variables to control for the quality of care. First, infant mortality is a well known measure for the quality of a healthcare system. Moreover, infant mortality is not directly related to our measure of mortality which starts at age 45.  On average there are almost four dead infants (younger than one year of age at death) per 1000 live births. But for some regions this almost reaches 16 per 1000 live births. The second quality measure is the number of physicians per 100k inhabitants. On average there are 380 physicians per 100k inhabitants but this varies between regions from 180 to 800. We view this as an approximate measure of resources available for healthcare in a region. Finally, we use the fraction of healthcare expenditure paid out-of-pocket as a signal of how generous health insurance is. This captures country wide policy. On average people pay a bit more than 20% out-of-pocket but this varies from 12% in some countries to more than 40% in others.
</p>



<table id="orge5ea27f" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> Summary statistics main variables</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">count</th>
<th scope="col" class="org-right">mean</th>
<th scope="col" class="org-right">std</th>
<th scope="col" class="org-right">min</th>
<th scope="col" class="org-right">median</th>
<th scope="col" class="org-right">max</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">population</td>
<td class="org-right">42900</td>
<td class="org-right">5961.0</td>
<td class="org-right">3788.7</td>
<td class="org-right">574.0</td>
<td class="org-right">5286.0</td>
<td class="org-right">30491.0</td>
</tr>

<tr>
<td class="org-left">deaths</td>
<td class="org-right">42900</td>
<td class="org-right">88.9</td>
<td class="org-right">83.7</td>
<td class="org-right">0</td>
<td class="org-right">62.0</td>
<td class="org-right">867.0</td>
</tr>

<tr>
<td class="org-left">mortality (%)</td>
<td class="org-right">42900</td>
<td class="org-right">1.8</td>
<td class="org-right">1.9</td>
<td class="org-right">0</td>
<td class="org-right">1.2</td>
<td class="org-right">17.3</td>
</tr>

<tr>
<td class="org-left">deprivation (%)</td>
<td class="org-right">481</td>
<td class="org-right">9.9</td>
<td class="org-right">13.3</td>
<td class="org-right">0</td>
<td class="org-right">2.8</td>
<td class="org-right">55.2</td>
</tr>

<tr>
<td class="org-left">too expensive (%)</td>
<td class="org-right">527</td>
<td class="org-right">1.5</td>
<td class="org-right">2.6</td>
<td class="org-right">0</td>
<td class="org-right">0.5</td>
<td class="org-right">18.4</td>
</tr>

<tr>
<td class="org-left">unmet (%)</td>
<td class="org-right">527</td>
<td class="org-right">6.4</td>
<td class="org-right">4.6</td>
<td class="org-right">0.7</td>
<td class="org-right">5.1</td>
<td class="org-right">28.1</td>
</tr>

<tr>
<td class="org-left">infant mortality (\textperthousand)</td>
<td class="org-right">705</td>
<td class="org-right">3.8</td>
<td class="org-right">2</td>
<td class="org-right">0.8</td>
<td class="org-right">3.4</td>
<td class="org-right">15.8</td>
</tr>

<tr>
<td class="org-left">physicians per 100k inhab.</td>
<td class="org-right">594</td>
<td class="org-right">379.4</td>
<td class="org-right">108.6</td>
<td class="org-right">180</td>
<td class="org-right">363.3</td>
<td class="org-right">807.9</td>
</tr>

<tr>
<td class="org-left">out-of-pocket (%)</td>
<td class="org-right">55</td>
<td class="org-right">22.8</td>
<td class="org-right">9.5</td>
<td class="org-right">12.0</td>
<td class="org-right">18.9</td>
<td class="org-right">43.2</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-org416b1af" class="outline-3">
<h3 id="org416b1af"><span class="section-number-3">3.1.</span> data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></h3>
<div class="outline-text-3" id="text-3-1">
<p>
The following python code generates Table <a href="#orge5ea27f">2</a> with summary statistics. The noweb notation <code>&lt;&lt;code-preamble&gt;&gt;</code> runs the code from Listing <a href="#org3b7ed1f">2</a> into the python cell without using copy/paste.
</p>


<div class="org-src-container">
<pre class="src src-jupyter-python">&lt;&lt;code-preamble&gt;&gt;
&lt;&lt;code-data&gt;&gt;
&lt;&lt;code-selection&gt;&gt;
<span style="color: #e95678;">stat_list</span> = []
<span style="color: #b877db;">def</span> <span style="color: #87ceeb;">summary_statistics</span>(var,name,stat_list=stat_list):
   <span style="color: #b877db;">return</span>  stat_list.append([name,np.<span style="color: #b877db;">sum</span>(~np.isnan(var)),np.nanmean(var).<span style="color: #b877db;">round</span>(decimals=1),np.nanstd(var).<span style="color: #b877db;">round</span>(decimals=1),np.nanmin(var).<span style="color: #b877db;">round</span>(decimals=1),np.nanmedian(var).<span style="color: #b877db;">round</span>(decimals=1),np.nanmax(var).<span style="color: #b877db;">round</span>(decimals=1)])

summary_statistics(P_cohort,<span style="color: #fab795;">'population'</span>)
summary_statistics(M_cohort,<span style="color: #fab795;">'deaths'</span>)
summary_statistics(M_cohort/P_cohort*100,<span style="color: #fab795;">'mortality (%)'</span>)
<span style="color: #e95678;">variables</span> = [Deprivation.values*100,TooExp.values*100,Unmet.values*100,m_infant.values*100,ds[<span style="color: #fab795;">'number_physicians per inhabitant'</span>].values,OOP_c*100]
<span style="color: #e95678;">names</span> = [<span style="color: #fab795;">'deprivation (%)'</span>, <span style="color: #fab795;">'too expensive (%)'</span>,<span style="color: #fab795;">'unmet (%)'</span>,<span style="color: #fab795;">'infant mortality (</span><span style="color: #f09383;">\\</span><span style="color: #fab795;">textperthousand)'</span>,<span style="color: #fab795;">'physicians per 100k inhab.'</span>,<span style="color: #fab795;">'out-of-pocket (%)'</span>]
<span style="color: #b877db;">for</span> i <span style="color: #b877db;">in</span> <span style="color: #b877db;">range</span>(<span style="color: #b877db;">len</span>(variables)):
   summary_statistics(variables[i],names[i])

<span style="color: #e95678;">df</span> = pd.DataFrame(stat_list,columns= [<span style="color: #fab795;">''</span>,<span style="color: #fab795;">'count'</span>,<span style="color: #fab795;">'mean'</span>,<span style="color: #fab795;">'std'</span>,<span style="color: #fab795;">'min'</span>,<span style="color: #fab795;">'median'</span>,<span style="color: #fab795;">'max'</span>])

<span style="color: #e95678;">headers</span> = [<span style="color: #fab795;">'count'</span>,<span style="color: #fab795;">'mean'</span>,<span style="color: #fab795;">'std'</span>,<span style="color: #fab795;">'min'</span>,<span style="color: #fab795;">'median'</span>,<span style="color: #fab795;">'max'</span>]

<span style="color: #b877db;">print</span>(tabulate(df,headers,tablefmt=<span style="color: #fab795;">"orgtbl"</span>,\
               colalign=(<span style="color: #fab795;">"left"</span>,<span style="color: #fab795;">"left"</span>, <span style="color: #fab795;">"right"</span>, <span style="color: #fab795;">"right"</span>, <span style="color: #fab795;">"right"</span>, <span style="color: #fab795;">"right"</span>, <span style="color: #fab795;">"right"</span>, <span style="color: #fab795;">"right"</span>)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org71a2565" class="outline-2">
<h2 id="org71a2565"><span class="section-number-2">4.</span> Estimation</h2>
<div class="outline-text-2" id="text-4">
<p>

</p>

<p>
We estimate the model using Bayesian methods. Here we present the equations of the model. The online appendix contains the details on the choice of priors and the <code>pymc</code> code of the model. Further, we explain how the Bayesian algorithm deals with missing observations.
</p>

<p>
We present the model in reverse order. We observe the number of deaths \(m\) and the population size \(n\) per age/gender/region/year dimensions. We model the probability of death \(\mu\) and \(m\) has a Binomial distribution:
</p>
\begin{equation}
\label{org9f37d5f}
m_{atr}^{i} = Binomial(n_{atr}^{i},\mu_{atr}^{i})
\end{equation}
<p>
where \(\mu_{atr}^i\) is given by equation \eqref{org2b148dd}. Poverty \(\alpha_{tr}\) per region and time period is observed in the data using the material deprivation measure discussed in the previous section. The fraction of people ill \(\iota_{atr}^{ij}\) varies by age \(a\), gender \(i\), time \(t\), region \(r\) and income level \(j\). This fraction \(\iota\) follows from difference equation \eqref{org628d60c}. Before we explain how this equation is estimated, recall that the estimate of \(\delta_{c}\) is allowed to vary by country \(c\).
</p>

<p>
To solve differential equation \eqref{org628d60c}, we start by estimating the initial condition \(\iota_{a0r}^{ij}\) for ages \(a=0-30\) (i.e. ages 45-74) in year \(t=0\) (2008) per region \(r\), gender \(i\) and income category \(j\).
</p>

<p>
Next, we need to estimate the probability of falling ill \(\pi_{ar}^{ij}\) which we assume to be additive in age, region, gender and income fixed effects in log-odds space. That is we add together the log-odds effects for age, gender, region and income and apply the inverse logit function \(e^x/(1+e^x)\) to the sum of these log-odds. This gives the probabilities \(\pi_{ar}^{ij} \in \langle 0,1 \rangle\).
</p>

<p>
The probability \(\sigma = \sigma_0 + \lambda (1-\upsilon)\) of recovering to full health in equation \eqref{org6e9dd24} is estimated as follows. We estimate the probability \(\sigma_0 \in \langle 0,1 \rangle\) of recovering to health without medical intervention. Further, we observe the fraction of people who indicate that they have unmet medical needs \(\upsilon_{tr}\) at the year/region level. For the ill who do get treatment, \(1-\upsilon\), there is a probability \(\lambda\) of full recovery. The logg-odds of \(\lambda\) are the sum of three effects: (i) year fixed effects, capturing that over time the quality of care improves due to technological progress, (ii) infant mortality and (iii) number of physicians per 100k inhabitants. The latter two capture the variation across time and region in quality of care. Again we use the inverse logit function to turn the log-odds into a probability \(\lambda\). 
</p>

<p>
We expect both the probability of unmet medical needs because it is too expensive, \(\tau\), and for other reasons, \(\upsilon_o\), to be bigger for low incomes than for high incomes. If your income is higher, you are less likely to skip a treatment because it is too expensive: \(\tau^j = \zeta^j oop\) with \(\zeta^l \geq \zeta^h\) and the fraction of medical expenditure paid out-of-pocket \(oop_{tc}\) varies with country and time. Further, also with the other reasons for unmet medical needs (like waiting lists) we expect \(\upsilon_o^l \geq \upsilon_o^h\). Hence, we find that
</p>
\begin{equation}
\label{org8dbf3ff}
\upsilon_{tr} = \alpha_{tr} (\zeta^{l} oop_{tc} + \upsilon_{otr}^l) + (1-\alpha_{tr}) (\zeta^h oop_{tc} + \upsilon_{otr}^{h})
\end{equation}
<p>
where we observe \(\tau_{tr} = (\alpha_{tr} \zeta^l + (1-\alpha_{tr}) \zeta^h) oop_{tc}\) and \(\upsilon_{otr} = \alpha_{tr} \upsilon^l_{otr} + (1-\alpha_{tr}) \upsilon^h_{otr}\).
</p>

<p>
Hence we find
</p>
\begin{equation}
\label{org8a0538d}
\sigma_{tr}^{j} = \sigma_{0} + \lambda_{tr} (1-\zeta^j oop_{tc} - u_{otr}^{j})
\end{equation}

<p>
Given that we estimate the initial conditions \(\iota_0\) and the parameters \(\pi_a, \sigma, \delta\) we can solve differential equation \eqref{org628d60c} to find \(\iota_{atr}^i\) and thus calculate the probability of death \(\mu_{atr}^i\) in equation \eqref{org2b148dd} as input in the Binomial distribution \eqref{org9f37d5f}.
</p>

<p>
One of the conceptual advantages of a Bayesian model is that there is no clear distinction between data and parameters. Both are basically distributions. This comes to the fore when dealing with missing values which are prevalent in our data as shown in Table <a href="#orge5ea27f">2</a>. The Markov Chain Monte Carlo (MCMC) algorithm generates the posterior distribution of parameters by drawing samples from this distribution. For each parameter we will have 4 chains of 2000 draws, that is 8000 draws from the posterior distribution. When an observation is missing, the algorithm will randomly draw the observation from a pre-defined distribution. This implies that each draw is different signalling the uncertainty that surrounds the missing observation. This is better than imputing the value of the observation as the latter suggests that we are as certain about the imputed value as we are about an observed value; which is obviously not the case.
</p>

<p>
For variables based on summation, it is natural to assume a normal distribution for missing observations. The expectation (standard deviation) of this distribution is then given by the average value (standard deviation) of the observations that we do have for this region or country.
</p>

<p>
To improve the efficiency of the algorithm in solving the difference equation while estimating the parameters, the data is not in (two dimensional) dataframe format. Instead we work with multi-dimensional tensors. To illustrate, the tensors with the population and deaths data are 4-dimensional tensors with coordinates age/gender/year/region. The difference equation then iterates over age and calendar year using <a href="https://pytensor.readthedocs.io/en/latest/library/scan.html">pytensor&rsquo;s <code>scan</code> function</a>. See the online appendix for details.
</p>
</div>
<div id="outline-container-org305f468" class="outline-3">
<h3 id="org305f468"><span class="section-number-3">4.1.</span> Identification strategy and limitations</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Our identification strategy is grounded in a structural modeling approach rather than exogenous quasi-experimental variation. We estimate a dynamic Markov model of health status transitions using cohort-level Eurostat data, where the key policy variable, \(oop\), varies across countries and over time. We link these variations in cost-sharing to observed differences in recovery rates and mortality, conditional on region, age, gender, income, time fixed effects and variables capturing healthcare quality.
</p>

<p>
The strength of this approach lies in its ability to simulate long-run effects by modeling underlying health dynamics. Unlike DiD estimators, which compare limited time points before and after a reform, our framework accumulates the effects of delayed or forgone treatment over multiple years. It also allows us to examine heterogeneity by income and gender and to propagate parameter uncertainty through Bayesian inference.
</p>

<p>
However, this comes with trade-offs. Our identification of the effects of cost-sharing relies on structural assumptions, notably the specification of the Markov transition probabilities. Further, \(oop\) variation is not derived from a policy discontinuity or random assignment. As such, our estimates could be biased by omitted variables that simultaneously influence health and insurance \(oop\) (e.g. austerity-induced cuts to both healthcare quality and insurance generosity). We address this concern through robustness checks: (i) the inclusion of unemployment and education to capture lifestyle differences between regions and GDP per capita and imaging device availability as additional controls for healthcare quality and (ii) a placebo test using traffic mortality which should not have the dynamic structure of mortality that we analyse but can be negatively affected by fiscal austerity.
</p>

<p>
While these checks support the plausibility of our identification, we acknowledge that the approach does not deliver the same level of internal validity as natural experiments. Our findings should therefore be interpreted as credible simulations under a structural model, rather than precise causal point estimates in the experimental sense.
</p>
</div>
</div>
<div id="outline-container-orgc4000e1" class="outline-3">
<h3 id="orgc4000e1"><span class="section-number-3">4.2.</span> estimation code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></h3>
<div class="outline-text-3" id="text-4-2">
<p>
In estimating the model we follow the age cohorts 45-74 over time from 2008 to 2018 when they are aged 55-84. For each age/gender/income/region category we split the population into low and high health status. We use <code>pymc</code>&rsquo;s <code>scan</code> function to follow the cohort over time according to the difference equation \eqref{org628d60c}. The function <code>transition</code> takes as inputs \(\pi,\sigma,\delta\) and this period&rsquo;s fraction of ill. The function returns next period&rsquo;s fraction of ill.
</p>

<p>
The dimensions for observed variables (&ldquo;data&rdquo;) and parameters are: age, gender, year, region and income. Not all variables or parameters have all these dimensions. E.g. some only vary by country (not region), some parameters are constant or only vary by year etc.
</p>

<p>
For our first year (2008) we specify the initial fraction of ill, \(\iota_0\). This parameter needs to be estimated and varies by cohort (45-74), gender, region and income. Most probabilities/fractions (like \(\iota_0\) and \(\delta\)) are specified in log-odds terms.
</p>

<p>
The probability of falling ill is specified as the addition of age, gender, country and income effects (additive in log-odds space).
</p>

<p>
Then the code specifies the distributions of a number of variables for which we have missing values. This is the case for the deprivation variable, OOP, unmet medical needs in total and for reasons other than the treatment is too expensive. Finally, there are also missing values for infant mortality and the number of physicians per 100k inhabitants. For variables that are between 0 and 1, we either use the <code>clip</code> function or specify a Beta distribution. For the Beta distribution we use the parametrization with mean effect <code>mu</code> and number of observations <code>nu</code>.
</p>

<p>
The expected number of people with unmet medical needs equals the sum of unmet needs for other reasons plus the fraction of people forgoing treatment because it is too expensive, \(\tau\). We observe \(\tau\) and split it up into \(\tau^l,\tau^h\) such that \(\tau = \alpha \tau^l + (1-\alpha) \tau^h\). Similarly, We observe \(U_o\) and split it up into \(U_o^l, U_o^h\) such that \(U_o = \alpha U_o^l + (1-\alpha) U_o^h\). We do this as follows: \(U_o^j = \xi^j U_o\) with \(\alpha \xi^l + (1-\alpha) \xi^h = 1\) with \(\xi^l = \xi + \varepsilon \geq \xi = \xi^h\). Hence it follows from \(\alpha (\xi + \epsilon) + (1-\alpha) \xi = 1\) that \(\xi = 1-\alpha \varepsilon\) as we model it below in the code.
</p>

<p>
We know that an increase in oop makes it more likely that people skip treatment because it is too expensive. Hence we specify that \(\zeta^h \geq 0\) (in terms of <code>slope_ζ</code>) and that \(\zeta^l \geq \zeta^h\) using <code>delta_ζ</code>. Both parameters are modelled as HalfNormal to make sure they are non-negative.
</p>

<p>
We model the log-odds of \(\lambda\) as decreasing in infant mortality and increasing in the number of physicians.
</p>

<p>
The tensor \(I\) keeps track of the fraction ill per year, cohort, gender, region and income category. Its first &ldquo;row&rdquo; is given by \(\iota_0\) which we discussed above.
</p>

<p>
To determine the probability of death per year, cohort, gender and region, we sum over the income dimension as our data does not specify deaths by income category.
</p>

<p>
Given this, the number of deaths, <code>M_cohort</code> is a Binomial distribution with parameter \(n\) equal to the population size <code>P_cohort</code> and \(p\) equal to \(\mu\).
</p>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>code-model</label><pre class="src src-jupyter-python" id="org8de1485"><span style="color: #b877db;">def</span> <span style="color: #87ceeb;">transition</span>(&#960;,&#963;,I,&#948;):
    <span style="color: #e95678;">fit</span> = I*&#963;+(1-&#960;)*(1-I)
    <span style="color: #e95678;">ill</span> = &#960;*(1-I)+pt.clip(1-&#963;-&#948;,0.0,1.0)*I
    <span style="color: #e95678;">fraction_ill</span> = ill/(fit+ill)
    <span style="color: #b877db;">return</span> fraction_ill

<span style="color: #e95678;">n_y</span> = 2 <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">low/high income
</span><span style="color: #e95678;">n_g</span> = 2 <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">female/male
</span><span style="color: #e95678;">countries</span> = np.array([<span style="color: #fab795;">'Bulgaria'</span>, <span style="color: #fab795;">'Switzerland'</span>, <span style="color: #fab795;">'Denmark'</span>, <span style="color: #fab795;">'Greece'</span>, <span style="color: #fab795;">'Finland'</span>, <span style="color: #fab795;">'Hungary'</span>, <span style="color: #fab795;">'Lithuania'</span>, <span style="color: #fab795;">'Norway'</span>, <span style="color: #fab795;">'Sweden'</span>, <span style="color: #fab795;">'Slovenia'</span>, <span style="color: #fab795;">'Slovakia'</span>])
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">index: age, gender, year, region, income
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">for some variables we use country instead of region
</span>
<span style="color: #e95678;">coords</span> = {
    <span style="color: #fab795;">"region"</span> : ds.nuts2.values,\
    <span style="color: #fab795;">"ages"</span> : ds.age.values,\
    <span style="color: #fab795;">"cohort"</span> : age_matrix[0],\
    <span style="color: #fab795;">"gender"</span> : ds.sex.values,\
    <span style="color: #fab795;">"year"</span> : ds.year.values,\
    <span style="color: #fab795;">"income"</span> : [<span style="color: #fab795;">'y_l'</span>,<span style="color: #fab795;">'y_h'</span>],\
    <span style="color: #fab795;">"country"</span>: countries,\
     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">we define dummy dimensions for parameters that do not
</span>     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">vary by this dimension
</span>     <span style="color: #fab795;">"dummy0"</span>: np.arange(1),\
     <span style="color: #fab795;">"dummy1"</span>: np.arange(1),\
     <span style="color: #fab795;">"dummy2"</span>: np.arange(1)}

<span style="color: #b877db;">with</span> pm.Model(coords=coords) <span style="color: #b877db;">as</span> AR_model:
    <span style="color: #e95678;">logodds_&#953;</span> = pm.Normal(<span style="color: #fab795;">"logodds_&#953;"</span>,-4.0,1,\
              dims=(<span style="color: #fab795;">"cohort"</span>,<span style="color: #fab795;">"gender"</span>,<span style="color: #fab795;">"region"</span>,<span style="color: #fab795;">"income"</span>),\
              shape=(cohorts,n_g,n_regions,n_y)) 
    <span style="color: #e95678;">&#953;_0</span> = pm.Deterministic(<span style="color: #fab795;">"&#953;_0"</span>,pm.math.invlogit(logodds_&#953;),dims=(<span style="color: #fab795;">"cohort"</span>,<span style="color: #fab795;">"gender"</span>,<span style="color: #fab795;">"region"</span>,<span style="color: #fab795;">"income"</span>))
    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">&#953;_0 is used to start the sequence in scan =&gt;
</span>    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">no need to add age dimension: we build up the matrix I by following each cohort over the years
</span>    <span style="color: #e95678;">logodds_&#948;</span> = pm.Normal(<span style="color: #fab795;">"logodds_&#948;"</span>,-2.5,0.05,dims=(<span style="color: #fab795;">"country"</span>)) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">conditional on being ill, same prob. of death
</span>    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">&#948; is a non_sequence in the scan loop; no need to add age as a dimension
</span>    <span style="color: #e95678;">&#948;</span> = pm.Deterministic(<span style="color: #fab795;">"&#948;"</span>,pt.dot(pm.math.invlogit(logodds_&#948;), country_region_matrix_01)[<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>,:,<span style="color: #f09383;">None</span>])
    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">we build up the prior for &#960;
</span>    <span style="color: #e95678;">logodds_age_&#960;</span> = pm.Normal(<span style="color: #fab795;">"logodds_age_&#960;"</span>,log_odds_mort.mean(axis=(1,2,3)),log_odds_mort.std(axis=(1,2,3)),dims=(<span style="color: #fab795;">"ages"</span>))
    <span style="color: #e95678;">logodds_sex_&#960;</span> = pm.Normal(<span style="color: #fab795;">"logodds_sex_&#960;"</span>, gender_effect_&#960;, 0.05, dims=(<span style="color: #fab795;">"gender"</span>))
    <span style="color: #e95678;">logodds_country_&#960;</span> = pm.Normal(<span style="color: #fab795;">"logodds_country_&#960;"</span>,country_effect_&#960;,0.05, dims=(<span style="color: #fab795;">"country"</span>))
    <span style="color: #e95678;">logodds_&#960;</span> = pm.Deterministic(<span style="color: #fab795;">"logodds_&#960;"</span>,logodds_age_&#960;[:,<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>] + logodds_sex_&#960;[<span style="color: #f09383;">None</span>,:,<span style="color: #f09383;">None</span>] + pt.dot(logodds_country_&#960;, country_region_matrix_01)[<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>,:]) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">prob. of falling ill varies by age, gender and country
</span>    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">the priors do not impose that women tend to be healthier than men
</span>    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">but we do impose that people on low income tend to have low health status (high &#960;)
</span>    <span style="color: #e95678;">delta_&#960;</span> = pm.HalfNormal(<span style="color: #fab795;">"delta_&#960;"</span>,sigma=0.05,\
          dims=(<span style="color: #fab795;">"ages"</span>,<span style="color: #fab795;">"dummy0"</span>,<span style="color: #fab795;">"dummy1"</span>),\
          shape=(n_ages,1,1))
    <span style="color: #e95678;">&#960;</span> = pm.Deterministic(<span style="color: #fab795;">"&#960;"</span>,pt.stack([pm.math.invlogit(\
                                    logodds_&#960;+ delta_&#960;),\
                   pm.math.invlogit(logodds_&#960;)],axis=-1), dims=(<span style="color: #fab795;">"ages"</span>,<span style="color: #fab795;">"gender"</span>,<span style="color: #fab795;">"region"</span>,<span style="color: #fab795;">"income"</span>))
    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">when we draw missing values for OOP, we should draw the same value for all regions/age/gender in the same country
</span>    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">this we do via oop_c which we later bring back to region dimension with country_region_matrix_01
</span>    <span style="color: #e95678;">pov</span> = pm.Normal(<span style="color: #fab795;">"pov"</span>, mean_depr[<span style="color: #f09383;">None</span>,:], std_depr[<span style="color: #f09383;">None</span>,:], observed=Deprivation,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>)) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fraction of people on low income
</span>    <span style="color: #e95678;">poverty</span> = pt.stack([pt.clip(pov,0,1),1-pt.clip(pov,0,1)],axis=-1) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">vector with fraction of low/high income people
</span>    <span style="color: #e95678;">oop_c</span> = pm.Normal(<span style="color: #fab795;">"oop_c"</span>, mean_oop_c[<span style="color: #f09383;">None</span>,:], std_oop_c[<span style="color: #f09383;">None</span>,:], observed=OOP_c,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"country"</span>))
    <span style="color: #e95678;">oop</span> = pt.dot(oop_c,country_region_matrix_01)

    <span style="color: #e95678;">slope_&#950;</span> = pm.HalfNormal(<span style="color: #fab795;">"slope_&#950;"</span>,sigma=0.05)
    <span style="color: #e95678;">delta_&#950;</span> = pm.HalfNormal(<span style="color: #fab795;">"delta_&#950;"</span>,sigma=0.05)
    <span style="color: #e95678;">&#950;</span> = pm.Deterministic(<span style="color: #fab795;">"&#950;"</span>,pt.stack([(slope_&#950;+ delta_&#950;),\
                   (slope_&#950;)],axis=-1),dims=(<span style="color: #fab795;">"income"</span>)) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">varies with income
</span>    <span style="color: #e95678;">&#964;</span> = pm.Deterministic(<span style="color: #fab795;">"&#964;"</span>, &#950;[<span style="color: #f09383;">None</span>,:]*oop[:,:,<span style="color: #f09383;">None</span>])
    <span style="color: #e95678;">mu_U_o</span> = Unmet_o.mean(axis=0).values[<span style="color: #f09383;">None</span>,:]
    <span style="color: #e95678;">nu_U_o</span> = pm.Exponential(<span style="color: #fab795;">"nu_U_o"</span>, 0.05)
    <span style="color: #e95678;">U_o</span> = pm.Beta(<span style="color: #fab795;">"U_o"</span>, alpha = mu_U_o*nu_U_o, beta = (1-mu_U_o)*nu_U_o,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>), observed=Unmet_o)
    <span style="color: #e95678;">mu_U</span> = pt.clip(U_o+pt.<span style="color: #b877db;">sum</span>(poverty*&#964;,axis=2),0.000001,0.9999)
    <span style="color: #e95678;">nu_U</span> = pm.Exponential(<span style="color: #fab795;">"nu_U"</span>, 0.05)
    <span style="color: #e95678;">U</span> = pm.Beta(<span style="color: #fab795;">"U"</span>,alpha=mu_U*nu_U, beta=(1-mu_U)*nu_U,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>), observed=Unmet)
    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">&#955; measures prob. patient heals if treated (i.e. one minus unmet)
</span>    <span style="color: #e95678;">M_infant</span> = pm.Normal(<span style="color: #fab795;">"M_infant"</span>,mean_m_infant[<span style="color: #f09383;">None</span>,:],std_m_infant[<span style="color: #f09383;">None</span>,:],dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>),observed=m_infant)
    <span style="color: #e95678;">Physicians</span> = pm.Normal(<span style="color: #fab795;">"Physicians"</span>,mean_physician[<span style="color: #f09383;">None</span>,:],std_physician[<span style="color: #f09383;">None</span>,:],dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>),observed=physicians)
    <span style="color: #e95678;">lambda_1</span> = pm.HalfNormal(<span style="color: #fab795;">"lambda_1"</span>,sigma=0.01)
    <span style="color: #e95678;">lambda_2</span> = pm.HalfNormal(<span style="color: #fab795;">"lambda_2"</span>,sigma=0.01)
    <span style="color: #e95678;">lamba_0</span> = pm.Normal(<span style="color: #fab795;">"lambda_0"</span>,-4.1,0.05,dims=(<span style="color: #fab795;">"year"</span>))
    <span style="color: #e95678;">logodds_&#955;</span> = pm.Normal(<span style="color: #fab795;">"logodds_&#955;"</span>,lamba_0[:,<span style="color: #f09383;">None</span>]-lambda_1*M_infant+lambda_2*Physicians,0.1)
    <span style="color: #e95678;">&#955;</span> = pm.Deterministic(<span style="color: #fab795;">"&#955;"</span>,pm.math.invlogit(logodds_&#955;))<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">&#955; is between 0 and 1
</span>    <span style="color: #e95678;">&#949;</span> = pm.Beta(<span style="color: #fab795;">"&#949;"</span>,1,3) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">&#949; = &#958;_l - &#958;_h &gt; 0
</span>    <span style="color: #e95678;">&#958;</span> = 1-poverty[:,:,0]*&#949;
    <span style="color: #e95678;">&#965;</span> = pm.Deterministic(<span style="color: #fab795;">"&#965;"</span>, pt.stack([(&#958;+&#949;)*U_o,&#958;*U_o],axis=-1) + &#964;)
    <span style="color: #e95678;">&#963;_0</span> = pm.Beta(<span style="color: #fab795;">"&#963;_0"</span>,1,3)
    <span style="color: #e95678;">&#963;</span> = pm.Deterministic(<span style="color: #fab795;">"&#963;"</span>,pt.clip(&#963;_0+&#955;[:,<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>,:,<span style="color: #f09383;">None</span>]*(1-&#965;)[:,<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>,:,:],0,1))
    <span style="color: #e95678;">I</span> = pt.zeros((t_dim,cohorts,n_g,n_regions,n_y))
    <span style="color: #e95678;">I</span> = pt.set_subtensor(I[0],&#953;_0)

    <span style="color: #e95678;">outputs</span>, <span style="color: #e95678;">updates</span> = pytensor.scan(
        transition,
     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">age/year is the dynamic part of the model
</span>     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">i.e. first dimension of &#960;
</span>        sequences=[<span style="color: #b877db;">dict</span>(<span style="color: #b877db;">input</span>=&#960;[age_indices]),<span style="color: #b877db;">dict</span>(<span style="color: #b877db;">input</span>=&#963;)], <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">check sequences with order of arguments in =transition=
</span>     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">we loop over the first dimension: age
</span>     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">the initial value for I (at low_age)
</span>     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">outputs_info has no age dimension
</span>        outputs_info=[<span style="color: #b877db;">dict</span>(initial=&#953;_0)],
     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">variables that have no age dimension:
</span>        non_sequences=[&#948;[0]],
    )

    <span style="color: #e95678;">I</span> = pt.set_subtensor(I[1:],outputs[:t_dim-1])
    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">&#956; is probability of death for age/gender/year/region
</span>    <span style="color: #e95678;">ill</span> = pm.Deterministic(<span style="color: #fab795;">"ill"</span>,I)
    <span style="color: #e95678;">&#956;</span> = pm.Deterministic(<span style="color: #fab795;">"&#956;"</span>,(pt.<span style="color: #b877db;">sum</span>(&#948;*I*poverty[:,<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>,:,:],axis=4)))<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">aggregate over income
</span>    <span style="color: #e95678;">mortality</span> = pm.Binomial(<span style="color: #fab795;">"mortality"</span>,n=P_cohort,p=&#956;,observed=M_cohort,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"cohort"</span>,<span style="color: #fab795;">"gender"</span>,<span style="color: #fab795;">"region"</span>))

</pre>
</div>
</div>
<div id="outline-container-org176c85b" class="outline-4">
<h4 id="org176c85b">choice of priors</h4>
<div class="outline-text-4" id="text-org176c85b">
<p>
For choosing prior distributions, we use the following rules of thumb. If we know from previous studies or from the model that a parameter is positive, we model the prior distribution as a HalfNormal. To illustrate, we know that people on low income have a lower health status than high income. We model this as low incomes having a higher probability of falling ill <code>delta_π</code> being positive. Similarly, the effect of oop on the fraction of people forgoing treatment because it is too expensive, \(\zeta\), can only be positive: <code>slope_ζ</code> has a HalfNormal distribution. If we have no a priori knowledge of the sign of a parameter, we model its prior distribution as a Normal distribution. Finally, we use three ways to make sure that a parameter is between 0 and 1. We model the log offs of the parameters and use the inverse logit to get to probabilities. Second, we use a Beta distribution and third we clip the parameter to get a value between 0 and 1. The choice here is partly arbitrary and driven by coding convenience.
</p>

<p>
Further, we use regularizing (&ldquo;seat-belt&rdquo;) priors: the mode of the prior distribution is set to 0 and we choose a relatively small standard deviation. The parameter then only &ldquo;significantly&rdquo; deviates from 0 if there is strong evidence for this in the data. 
</p>

<p>
From prior distributions on individual parameters it is hard to understand what the interplay is between these parameters. How do all these distributions add up to the mortality measure we are ultimately interested in?
</p>

<p>
To get an idea whether or not the choice of prior distributions in the model makes sense, we can compare the distribution of mortality generated by priors only (prior predictive distribution) with the observed distribution of mortality in the data.
</p>

<p>
We first generate the prior predictive of the model.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">prior_samples</span> = pm.sample_prior_predictive(samples=500, model=AR_model)
</pre>
</div>

<pre class="example">
Sampling: [M_infant_observed, M_infant_unobserved, Physicians_observed, Physicians_unobserved, U_o_observed, U_o_unobserved, U_observed, U_unobserved, delta_ζ, delta_π, lambda_0, lambda_1, lambda_2, logodds_age_π, logodds_country_π, logodds_sex_π, logodds_δ, logodds_ι, logodds_λ, mortality, nu_U, nu_U_o, oop_c_observed, oop_c_unobserved, pov_observed, pov_unobserved, slope_ζ, ε, σ_0]
</pre>


<p>
Then we plot the prior predictive with the observed mortality in the data.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">plt.hist( prior_samples.prior_predictive.mortality.values.flatten(),bins=100,density=<span style="color: #f09383;">True</span>,label=<span style="color: #fab795;">"prior predictive mortality"</span>);
plt.hist(M_cohort.flatten(),bins=100,density=<span style="color: #f09383;">True</span>,alpha=0.7,label=<span style="color: #fab795;">"observed mortality"</span>)
plt.xlim(0,400)
plt.xlabel(<span style="color: #fab795;">"Number of deaths"</span>)
plt.ylabel(<span style="color: #fab795;">"frequency"</span>)
plt.title(<span style="color: #fab795;">"Distributions of observed and prior predictive mortality"</span>)
plt.legend();
</pre>
</div>


<div id="org8fd15bb" class="figure">
<p><img src="./figures/prior_predictive.png" alt="prior_predictive.png" />
</p>
</div>

<p>
As the figure shows, before the model &ldquo;sees the data&rdquo; its predictions on mortality (across age/gender/regions/year) are in the ball park of observed mortality. The model tends to predict (too) low mortality but this will be fixed once we estimate the parameters below. 
</p>
</div>
</div>
<div id="outline-container-org7750cdf" class="outline-4">
<h4 id="org7750cdf">sampling</h4>
<div class="outline-text-4" id="text-org7750cdf">
<p>
In order to sample from the posterior distribution of our parameters, we call all relevant code blocks above and sample using the Markov Chain Monte Carlo NUTS sampler.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">&lt;&lt;code-preamble&gt;&gt;
&lt;&lt;code-data&gt;&gt;
&lt;&lt;code-selection&gt;&gt;
&lt;&lt;code-matrices&gt;&gt;
&lt;&lt;code-variables&gt;&gt;
&lt;&lt;code-cohorts&gt;&gt;
&lt;&lt;code-moments&gt;&gt;
&lt;&lt;code-model&gt;&gt;
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">with AR_model:
</span><span style="color: #4e5059; font-style: italic;">#     </span><span style="color: #4e5059; font-style: italic;">idata = pm.sample(draws=2000,target_accept = 0.95)
</span><span style="color: #4e5059; font-style: italic;">#     </span><span style="color: #4e5059; font-style: italic;">pm.sample_posterior_predictive(idata,\
</span><span style="color: #4e5059; font-style: italic;">#                                    </span><span style="color: #4e5059; font-style: italic;">extend_inferencedata=True)
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">idata.to_netcdf("./trace/baseline_model_lambda.nc")</span>
</pre>
</div>

<pre class="example" id="orgd236c77">
/var/folders/g3/0hgyvgbn6x3105r_s_rgnrx40000gn/T/ipykernel_88754/85024763.py:84: RuntimeWarning: Mean of empty slice
  mean_physician = np.nanmean(physicians,axis=0) # mean over years
/Users/janboone/anaconda3/envs/pymc_env2/lib/python3.13/site-packages/numpy/lib/_nanfunctions_impl.py:2015: RuntimeWarning: Degrees of freedom &lt;= 0 for slice.
  var = nanvar(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
/Users/janboone/anaconda3/envs/pymc_env2/lib/python3.13/site-packages/pymc/model/core.py:1300: ImputationWarning: Data in pov contains missing values and will be automatically imputed from the sampling distribution.
  warnings.warn(impute_message, ImputationWarning)
/Users/janboone/anaconda3/envs/pymc_env2/lib/python3.13/site-packages/pymc/model/core.py:1300: ImputationWarning: Data in oop_c contains missing values and will be automatically imputed from the sampling distribution.
  warnings.warn(impute_message, ImputationWarning)
/Users/janboone/anaconda3/envs/pymc_env2/lib/python3.13/site-packages/pymc/model/core.py:1300: ImputationWarning: Data in U_o contains missing values and will be automatically imputed from the sampling distribution.
  warnings.warn(impute_message, ImputationWarning)
/Users/janboone/anaconda3/envs/pymc_env2/lib/python3.13/site-packages/pymc/model/core.py:1300: ImputationWarning: Data in U contains missing values and will be automatically imputed from the sampling distribution.
  warnings.warn(impute_message, ImputationWarning)
/Users/janboone/anaconda3/envs/pymc_env2/lib/python3.13/site-packages/pymc/model/core.py:1300: ImputationWarning: Data in M_infant contains missing values and will be automatically imputed from the sampling distribution.
  warnings.warn(impute_message, ImputationWarning)
/Users/janboone/anaconda3/envs/pymc_env2/lib/python3.13/site-packages/pymc/model/core.py:1300: ImputationWarning: Data in Physicians contains missing values and will be automatically imputed from the sampling distribution.
  warnings.warn(impute_message, ImputationWarning)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfd2702b" class="outline-2">
<h2 id="orgfd2702b"><span class="section-number-2">5.</span> Results</h2>
<div class="outline-text-2" id="text-5">
<p>
In this section we present the results of the estimation of the model. Before presenting the outcome of our estimation, we present some (graphical) checks of our model.
</p>
</div>
<div id="outline-container-orgd2870af" class="outline-3">
<h3 id="orgd2870af"><span class="section-number-3">5.1.</span> Model fit</h3>
<div class="outline-text-3" id="text-5-1">
<p>
A first check of the model is to see whether it fits the data. Figure <a href="#org162a99c">2</a> shows for all our observations the observed number of deaths on the horizontal axis and the predicted number on the vertical axis. Further, for each prediction we add a dashed vertical line representing the 95% prediction interval (of the posterior predictive distribution). The predictions clearly follow the 45-degree line and almost all 95% prediction intervals intersect the 45-degree line. In this sense the model fit seems quite good.
</p>


<div id="org162a99c" class="figure">
<p><img src="./figures/fit_model.png" alt="fit_model.png" />
</p>
<p><span class="figure-number">Figure 2: </span>Observed vs predicted number of deaths (per age/gender/region/year) together with the 95% prediction intervals.</p>
</div>

<p>
Figure <a href="#orge50c38e">7</a> in the appendix presents the trace plots and Table <a href="#orgb8e8f7b">8</a> r-hat values for estimated parameters. The r-hat values are close to one and the traceplots satisfy the following three criteria. First, the plots in the right column of the figure are stationary; that is, not trending upward or downward. This implies that the posterior mean of the coefficient is (more or less) constant as we sample. Second, there is good mixing which translates in condensed zig-zagging. In other words, the algorithm manages to draw values across the whole domain of the posterior quickly one after the other. Finally, the four chains cover the same regions. This is most easily checked in the left column of the trace plot. The three features are satisfied in the figure. All this indicates that the MCMC algorithm manages to sample the posterior distribution correctly.
</p>

<p>
To gain an intuition on how the model works, Figure <a href="#org0f5c90d">3</a> shows a number of estimated outcomes. The top-left panel shows the probability of falling ill, \(\pi\), as a function of age for women and men.<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup> This probability is quite low around age 45 and increases to 40% for men in their eighties. As shown in the panel below this one, the probability of death &#x2013;conditional on being ill&#x2013; is above 10% per year. In other words, falling ill in our model  does not refer to a regular cough or breaking a leg. The observation that the average probability of falling ill is higher for men than for women is in line with the observation that women tend to live longer than men. The 95% posterior probability interval shows that there is quite some variation in the probability of falling ill at older ages but that uncertainty is small till age 75. In order not to crowd the figure we do not report the 95% intervals for males but they are of similar magnitude.
</p>

<p>
The top-right panel shows the country offsets (in log-odds terms) for four countries. There is a clear dichotomy between Switzerland and Norway on the one hand and Lithuania and Hungary on the other. But even between these countries there is hardly overlap between the distributions. Of these four countries, people in Switzerland are least likely to fall ill (at any age) and in Hungary most likely.
</p>

<p>
Similarly, the probability of dying conditional on being ill, \(\delta_{c}\), varies by country. Of the four countries presented, it is lowest for Denmark and Finland and highest for Hungary and Bulgaria.
</p>

<p>
Finally, the bottom-right panel shows the fraction of people ill for four categories: people aged 55 and 60 with low/high income. The fraction of people who are ill is higher for low than for high incomes, as one would expect. Also the fraction increases with age. The posterior distributions for these fractions do not overlap.
</p>


<div id="org0f5c90d" class="figure">
<p><img src="./figures/summary_figure.png" alt="summary_figure.png" />
</p>
<p><span class="figure-number">Figure 3: </span>Summary of selected features of the model. Top left panel shows the age profile for \(\pi\) for women and men. Top right panel shows the country offsetts in the log-odds of \(\pi\) and bottom left panel the probability of death \(\delta_c\) for selected countries. Bottom right panel shows the fraction of two age groups who are in the low health state for low and high incomes.</p>
</div>
</div>
</div>
<div id="outline-container-org8e80046" class="outline-3">
<h3 id="org8e80046"><span class="section-number-3">5.2.</span> Analysis</h3>
<div class="outline-text-3" id="text-5-2">
<p>
The analysis in this section makes the following points. First, the expected qaly&rsquo;s for a 45 year old vary a lot between countries and within countries between gender and income categories. The concept of qaly&rsquo;s is much discussed in the literature; here we simply use it as a summary measure of the fractions of people in good health, poor health and deceased. Second, when we increase demand-side cost-sharing by ten percentage points (\(\Delta oop = 0.1\)), there is a clear but modest reduction in qaly&rsquo;s. Third, the effect is almost zero for people on high income but far higher for people on low income. In this sense, effect heterogeneity is high and considering the average effect (across incomes) is not informative. Finally, instead of comparing qaly&rsquo;s lost over, say, a thirty year time period (for which one needs a dynamic model), we can compare the loss in qaly&rsquo;s for the same age groups from one year before the increase in \(oop\) to one year after. The latter is close to a (static) measure used in most event study analyses. We show that the dynamic effect is an order of magnitude bigger than the estimated static effect.
</p>


<div id="org36f0553" class="figure">
<p><img src="./figures/summary_two_applications.png" alt="summary_two_applications.png" />
</p>
<p><span class="figure-number">Figure 4: </span>Summarizing two applications of the model: left panel shows the fraction of the maximum qaly&rsquo;s realized by country and the right panel shows qaly&rsquo;s lost due to 0.1 increase in \(oop\).</p>
</div>

<p>
Figure <a href="#org36f0553">4</a> summarizes the two applications that we analyse with the model. First, since our estimation method identifies the fraction of people who have low health status, we can derive qaly&rsquo;s using equation \eqref{org5faadf5}. In the figure we use \(\theta=0.6\): the quality of life for someone who is ill (and has a 10% probability of dying per year) is 60% of the quality of life for someone in full health. This is an arbitrary choice and obviously different choices can be made here. Different values for \(\theta\) changes the precise numerical values but not the main (qualitative) conclusions of the analysis; as we show in the robustness analysis.
</p>

<p>
The figure was made as follows. For each group (female/male, low/high income) of 45 year olds we create a population of 1000 individuals. At 45 we use our estimates of \(\iota_0\) to split the groups into low/high health status. With our estimated parameters \(\pi,\sigma,\delta\) we follow these individuals as they age over time till they are 85. Hence, for each group there are at max. 40,000 life-years (in full health) to be had over this period. For each subgroup gender/income we calculate the realized quality adjusted life-years and divide this by 40,000. The left panel of Figure <a href="#org36f0553">4</a> shows the qaly&rsquo;s realized for low income men and for high income women.  The panel shows that in, say Switzerland, low income males get 80% of the max. number of qaly&rsquo;s and high income females get 10% of 40,000 qaly&rsquo;s more. That is, the latter get 12.5% (\(0.10/0.80\)) more qaly&rsquo;s than the former. This gender/income gap ranges all the way up to 20% in Hungary, Bulgaria and Lithuania.
</p>

<p>
The panel on the right shows what happens if \(oop\) is increased by 0.1: people pay an additional 10% of their healthcare expenditure out-of-pocket for each country in our data. It turns out that the average effect is around 3.0:<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup> among 1000 people, a region/gender/income group loses 3 life-years for 45-85 year olds due to \(\Delta oop=0.1\). This effect is not huge (people do not just pass away because cost-sharing is increased), but it is clearly bounded away from 0.
</p>

<p>
What is more surprising is the effect heterogeneity for high and low incomes. The effect is almost ten times bigger for people on low income. People on high income hardly react in terms of healthcare expenditure to the increase in \(oop\) as they can afford it anyway. But for low incomes, the increase reduces their demand for treatment. This raises unmet medical needs because it is too expensive and hence, for this group, reduces the probability \(\sigma\) of recovering to the healthy state. This has two effects on their qaly&rsquo;s. First, the quality of life in the ill state is lower than in the healthy state. Second, staying longer in the ill state, increases the probability of death (compared to being in the healthy state).
</p>


<p>
Finally, we compare the dynamic (across years) qaly effect derived above with a year-on-year effect for the same ages. To avoid making additional assumptions we do this for the ages 45-74 in the first row of Table <a href="#org6103c20">1</a>. This is the cohort of ages that we use to estimate the model. Hence we have a well defined \(\iota_0\) fraction of people that are ill per age/gender/region/income category in the year before the reform. Then we use the equations for \(\tilde Q_0, \tilde Q_1\) defined in the theory section to find the static effect on qaly&rsquo;s. We compare this to the dynamic estimate in equation \eqref{org5faadf5} for the same ages till \(A=75\).
</p>


<table id="org3dd0539" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> Dynamic vs. static estimates of qaly&rsquo;s lost due to \(\Delta oop = 0.1\).</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">male</th>
<th scope="col" class="org-right">female</th>
<th scope="col" class="org-right">male</th>
<th scope="col" class="org-right">female</th>
</tr>

<tr>
<th scope="col" class="org-left">estimate</th>
<th scope="col" class="org-right">low income</th>
<th scope="col" class="org-right">low income</th>
<th scope="col" class="org-right">high income</th>
<th scope="col" class="org-right">high income</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(Q_0 - Q_1\)</td>
<td class="org-right">8.01</td>
<td class="org-right">5.23</td>
<td class="org-right">0.82</td>
<td class="org-right">0.46</td>
</tr>

<tr>
<td class="org-left">\(\tilde Q_0 - \tilde Q_1\)</td>
<td class="org-right">0.31</td>
<td class="org-right">0.24</td>
<td class="org-right">0.12</td>
<td class="org-right">0.06</td>
</tr>
</tbody>
</table>

<p>
As shown in Table <a href="#org3dd0539">3</a>, the dynamic low income estimates are lower than in Figure <a href="#org36f0553">4</a> (right panel): the dynamic estimates across ages till 75 are lower than over the full range till 85.
</p>

<p>
Comparing static and dynamic estimates shows that for this type of health model the dynamic estimates of qaly&rsquo;s lost \(Q_0-Q_1\) are a factor twenty higher for low incomes than the static estimates \(\tilde Q_0 - \tilde Q_1\). For high incomes the factor is around seven. As noted in section , we expect the dynamic effect to be bigger than the static effect because the former takes the effect on the stock of ill/healthy into account. However, the size of the difference is larger than one might have expected.
</p>


<p>
This suggests that for health models where an underlying (latent) health variable is important, short-term estimates (as often with a DiD analysis) severely under-estimate the overall effect of a policy change.
</p>

<p>
One can see the following trade-off. A DiD approach leads to a cleaner causal identification. It often allows for a convincing way to keep other factors constant. In contrast, identification in our model (which allows for a dynamic analysis) is based on underlying theory but suffers from potential missing variable bias. We show that for reasonable parameter values, the static estimate seriously under-estimates the effect compared to a dynamic one taking account of the cumulative effects over a life-time. In particular, we simulate the data using our dynamic model as true data generating process. Then we use static estimators to see what effects they identify.
</p>

<p>
Figure <a href="#orgf5e0f03">5</a> illustrates how a static estimate like DiD ignores the dynamics of health. The figure is an abstract representation of the DiD estimate of Finkelstein and McKnight (<a href="#citeproc_bib_item_4">2008</a>) analysing the introduction of Medicare in 1966 providing universal public health insurance to individuals aged 65 and over. To find the health effect of Medicare, the paper compares the average mortality rate of 65-74 year olds with the rate for 55-64 year olds both before and after the introduction of Medicare; the years 1952-1975. 
</p>

<p>
The logic of comparing age category 55-64 with 65-74 is the underlying assumption that the two categories do not differ except for the introduction of Medicare. This assumption would be harder to motivate when comparing 55-64 with 82 year olds. The idea of the paper is that if Medicare has substantial health effects one expects that the mortality rate for 65-74 year olds falls compared to 55-64 year olds after 1966. The paper does not find such an effect and the figure illustrates one mechanism why this can be the case.
</p>

<p>
To place this analysis in the context of our paper, we simulate the effect of a 10% point increase in oop (\(\Delta oop = 0.1\)) in year 0 for people aged 65 and over. Hence, in our model this implies that mortality will increase for the 65+ category (not decrease as in the Medicare example). We can simulate both the reform and the counterfactual and hence can make the comparison within age category; no need to compare the effect to 55-64 year olds. For this comparison between the DiD and dynamic estimates we only need the estimated parameters to be reasonable, not perfectly accurate. As shown above, this assumption seems to be satisfied with our estimated coefficients.
</p>

<p>
We do the simulations for low income men in one region in Bulgaria aged 65 and above who face \(\Delta oop = 0.1\) in year 0. On the horizontal axis we plot age for this group. The vertical axis shows the years after the introduction in year 0. The color intensity of a point indicates the number of years an agent has faced this higher oop. In the first year everyone aged 65 and above faced the higher out-of-pocket for one year (bottom row in the figure). In the second year, people aged 66 and over faced this for two years and the 65 year olds only for one year etc.
</p>

<p>
The horizontal black line in the left panel indicates the comparison group used in the paper (65-74) for year 10 (last year in the Finkelstein and McKnight (<a href="#citeproc_bib_item_4">2008</a>) data). The figure illustrates how &#x2013;from a dynamic point of view&#x2013; the effect gets diluted as the 65 year olds in this group have only experienced the reform for one year, the 66 year olds for two years etc. In contrast the blue diagonal line gives the true dynamic effect when we follow 65 year olds in year 0 till they become 83 with 19 years of increased oop. The diagonal includes points with a darkness intensity that the horizontal line does not capture for any of the years 0-18. In this sense, the static estimate under-estimates the true dynamic effect.
</p>

<p>
The right panel shows the consequences of this. The vertical axis shows the increase in mortality by age normalized on the average mortality effect for 65-74 year olds. Hence, the static estimate for 65-74 year olds in this figure is one by construction. But due to the dynamics of health in our model, the effect is first below 1 (till age 69) and then increases to six times the static estimate for 80 year olds. In order to identify this (far bigger) effect, one has to estimate a dynamic model capturing the age effects instead of relying on the DiD estimate. It will depend on the application whether a static precise causal identification is preferable or an estimate taking the dynamics of the problem into account but lacking a convincing causal foundation.
</p>


<div id="orgf5e0f03" class="figure">
<p><img src="./figures/years_treatment.png" alt="years_treatment.png" />
</p>
<p><span class="figure-number">Figure 5: </span>DiD vs. dynamic estimates of a 10% point increase in out-of-pocket expenditure for low income men aged 65 and over. The left panel shows the intensity of the effect across ages and years after the reform. The right panel shows the effect when following the 65 year old cohort till they are 83.</p>
</div>
</div>
</div>
<div id="outline-container-orge69bae2" class="outline-3">
<h3 id="orge69bae2"><span class="section-number-3">5.3.</span> model fit&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></h3>
<div class="outline-text-3" id="text-5-3">
<p>
As sampling takes some time, we generate the posterior samples once and save these. Here we read them in.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">idata</span> = az.from_netcdf(<span style="color: #fab795;">"./trace/baseline_model_lambda.nc"</span>)
</pre>
</div>

<p>
for the parameters where we do not have (too) many indices, we can summarize the results both in a table and with trace plots.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">pd.set_option(<span style="color: #fab795;">'display.max_rows'</span>, 75)

<span style="color: #e95678;">headers</span> = [<span style="color: #fab795;">'mean'</span>, <span style="color: #fab795;">'sd'</span>, <span style="color: #fab795;">'hdi_3%'</span>, <span style="color: #fab795;">'hdi_97%'</span>,\
           <span style="color: #fab795;">'ess_bulk'</span>, <span style="color: #fab795;">'r_hat'</span>]
<span style="color: #e95678;">variables</span> = [<span style="color: #fab795;">"logodds_sex_&#960;"</span>,<span style="color: #fab795;">"&#950;"</span>,<span style="color: #fab795;">"nu_U"</span>,<span style="color: #fab795;">"nu_U_o"</span>,<span style="color: #fab795;">"&#949;"</span>,<span style="color: #fab795;">"lambda_1"</span>,<span style="color: #fab795;">"lambda_2"</span>]
<span style="color: #e95678;">df_summary</span> = az.summary(idata,var_names=variables)[headers]
<span style="color: #b877db;">print</span>(tabulate(df_summary,\
               headers,tablefmt=<span style="color: #fab795;">'orgtbl'</span>,floatfmt=<span style="color: #fab795;">".2f"</span>))
</pre>
</div>

<pre class="example" id="org8fd04ea">
|                  |   mean |    sd |   hdi_3% |   hdi_97% |   ess_bulk |   r_hat |
|------------------+--------+-------+----------+-----------+------------+---------|
| logodds_sex_π[F] |  -0.19 |  0.03 |    -0.25 |     -0.13 |     349.00 |    1.01 |
| logodds_sex_π[M] |   0.50 |  0.03 |     0.44 |      0.56 |     354.00 |    1.01 |
| ζ[y_l]           |   0.27 |  0.01 |     0.25 |      0.30 |    8429.00 |    1.00 |
| ζ[y_h]           |   0.03 |  0.00 |     0.03 |      0.04 |    6048.00 |    1.00 |
| nu_U             | 299.81 | 18.94 |   264.86 |    336.40 |    7950.00 |    1.00 |
| nu_U_o           | 109.35 |  6.59 |    97.78 |    122.34 |    5584.00 |    1.00 |
| ε                |   0.07 |  0.07 |     0.00 |      0.19 |   10331.00 |    1.00 |
| lambda_1         |   0.01 |  0.01 |     0.00 |      0.02 |    6389.00 |    1.00 |
| lambda_2         |   0.06 |  0.01 |     0.04 |      0.07 |    1704.00 |    1.01 |
</pre>




<div class="org-src-container">
<pre class="src src-jupyter-python">plt.<span style="color: #e95678;">rcParams</span>[<span style="color: #fab795;">'figure.constrained_layout.use'</span>] = <span style="color: #f09383;">True</span>
az.plot_trace(idata,var_names=variables);
</pre>
</div>


<div id="orgd751214" class="figure">
<p><img src="./figures/trace.png" alt="trace.png" />
</p>
</div>

<p>
The following plot shows the observed number of deaths per age/gender/year/region categories against the model prediction.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">predictions</span> = idata.posterior_predictive.mortality.\
              mean(dim=(<span style="color: #fab795;">"chain"</span>,<span style="color: #fab795;">"draw"</span>)).values
<span style="color: #e95678;">perc_predictions</span> = np.percentile(idata.posterior_predictive.mortality.values,q=[2.5,97.5],axis=(0,1))
plt.vlines(M_cohort,perc_predictions[0],perc_predictions[1],color=<span style="color: #fab795;">'grey'</span>,linestyles=<span style="color: #fab795;">"dashed"</span>,linewidth=1,label=<span style="color: #fab795;">"95% interval"</span>,alpha=0.4)
plt.scatter((M_cohort),(predictions))
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">plt.scatter((M/Population).flatten(),(predictions/Population).flatten())
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">plt.plot([0,0.2],[0,0.2],c='k')
</span>plt.plot([0,860],[0,860],c=<span style="color: #fab795;">'k'</span>)
plt.legend()
plt.xlabel(<span style="color: #fab795;">"number of deaths"</span>)
plt.ylabel(<span style="color: #fab795;">"predicted number of deaths"</span>);
</pre>
</div>


<div id="orgb38faef" class="figure">
<p><img src="./figures/fit_model.png" alt="fit_model.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org68a1897" class="outline-3">
<h3 id="org68a1897"><span class="section-number-3">5.4.</span> results&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></h3>
<div class="outline-text-3" id="text-5-4">
<p>
We plot the age profile for the probability of falling ill, \(\pi\). As one would expect, this probability increases with age and is higher for men than for women. We plot the country offsets (in log-odds space) for four countries and the probability of death \(\delta_c\) for four (other) countries. Finally, we plot the fraction of people ill by income for two age categories.
</p>


<div class="org-src-container">
<pre class="src src-jupyter-python">plt.style.use(<span style="color: #fab795;">'Solarize_Light2'</span>)
fig, ((ax1,ax2),(ax3,ax4)) = plt.subplots(2, 2, dpi=140,figsize=(14,14))

<span style="color: #e95678;">pi_avg</span> = np.mean(idata.posterior.&#960;.values,axis=(0,1,4,5))
<span style="color: #e95678;">perc_pi</span> = np.percentile(idata.posterior.&#960;.values,[2.5,97.5],axis=(0,1,4,5))
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fig 1
</span>ax1.plot(np.arange(low_age,high_age-1),pi_avg[:-2,1],label=<span style="color: #fab795;">"male"</span>)
ax1.plot(np.arange(low_age,high_age-1),pi_avg[:-2,0],label=<span style="color: #fab795;">"female"</span>)
ax1.vlines(np.arange(low_age,high_age-1),perc_pi[0,:-2,0],perc_pi[1,:-2,0],color=<span style="color: #fab795;">'black'</span>,linestyles=<span style="color: #fab795;">"dashed"</span>,linewidth=1,label=<span style="color: #fab795;">"95% interval"</span>)
ax1.set_title(<span style="color: #fab795;">"Age profile of the probability of falling ill, $</span><span style="color: #f09383;">\\</span><span style="color: #fab795;">pi$,</span><span style="color: #f09383;">\n</span><span style="color: #fab795;"> and the 95% interval for females"</span>)
ax1.set_xlabel(<span style="color: #fab795;">'Age'</span>)
ax1.set_ylabel(<span style="color: #fab795;">'Probability'</span>)
ax1.legend();
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fig 2
</span><span style="color: #e95678;">post_logodds_pi</span> = idata.posterior.logodds_country_&#960;.values
sns.kdeplot(ax=ax2,data=post_logodds_pi[:,:,1].flatten(),label=<span style="color: #fab795;">"Switzerland"</span>)
sns.kdeplot(ax=ax2,data=post_logodds_pi[:,:,7].flatten(),label=<span style="color: #fab795;">"Norway"</span>)
sns.kdeplot(ax=ax2,data=post_logodds_pi[:,:,6].flatten(),label=<span style="color: #fab795;">"Lithuania"</span>)
sns.kdeplot(ax=ax2,data=post_logodds_pi[:,:,5].flatten(),label=<span style="color: #fab795;">"Hungary"</span>)
ax2.set_xlabel(<span style="color: #fab795;">"Log-odds falling ill"</span>)
ax2.set_title(<span style="color: #fab795;">"Country offsets falling ill, log-odds $</span><span style="color: #f09383;">\\</span><span style="color: #fab795;">pi$,</span><span style="color: #f09383;">\n</span><span style="color: #fab795;">for selected countries"</span>)
ax2.legend();
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fig 3
</span><span style="color: #e95678;">post_logodds_delta</span> = idata.posterior.logodds_&#948;.values
sns.kdeplot(ax=ax3,data=pm.math.invlogit(post_logodds_delta[:,:,2].flatten()).<span style="color: #b877db;">eval</span>(),label=<span style="color: #fab795;">"Denmark"</span>)
sns.kdeplot(ax=ax3,data=pm.math.invlogit(post_logodds_delta[:,:,4].flatten()).<span style="color: #b877db;">eval</span>(),label=<span style="color: #fab795;">"Finland"</span>)
sns.kdeplot(ax=ax3,data=pm.math.invlogit(post_logodds_delta[:,:,5].flatten()).<span style="color: #b877db;">eval</span>(),label=<span style="color: #fab795;">"Hungary"</span>)
sns.kdeplot(ax=ax3,data=pm.math.invlogit(post_logodds_delta[:,:,0].flatten()).<span style="color: #b877db;">eval</span>(),label=<span style="color: #fab795;">"Bulgaria"</span>)
ax3.set_xlabel(<span style="color: #fab795;">"Probability of dying"</span>)
ax3.set_title(<span style="color: #fab795;">"Probability of death conditional on being ill, $</span><span style="color: #f09383;">\\</span><span style="color: #fab795;">delta_c$"</span>)
ax3.legend();
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fig 4
</span><span style="color: #e95678;">ill_by_income</span> = idata.posterior.ill.values.mean(axis=(4,5))
ax4.hist(ill_by_income[:,:,10,0,1].flatten(),bins=70,density=<span style="color: #f09383;">True</span>,label=<span style="color: #fab795;">"55 year old, high income"</span>)
ax4.hist(ill_by_income[:,:,10,0,0].flatten(),bins=70,density=<span style="color: #f09383;">True</span>,label=<span style="color: #fab795;">"55 year old, low income"</span>)
ax4.hist(ill_by_income[:,:,10,5,1].flatten(),bins=70,density=<span style="color: #f09383;">True</span>,label=<span style="color: #fab795;">"60 year old, high income"</span>)
ax4.hist(ill_by_income[:,:,10,5,0].flatten(),bins=70,density=<span style="color: #f09383;">True</span>,label=<span style="color: #fab795;">"60 year old, low income"</span>)
ax4.set_xlabel(<span style="color: #fab795;">"Fraction ill"</span>)
ax4.set_ylabel(<span style="color: #fab795;">"Density"</span>)
ax4.set_title(<span style="color: #fab795;">"Fraction of people ill for</span><span style="color: #f09383;">\n</span><span style="color: #fab795;">55 and 60 year olds per income category"</span>)
ax4.legend();

</pre>
</div>


<div id="org052623c" class="figure">
<p><img src="./figures/summary_figure.png" alt="summary_figure.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org72d7b60" class="outline-3">
<h3 id="org72d7b60"><span class="section-number-3">5.5.</span> do analysis&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></h3>
<div class="outline-text-3" id="text-5-5">
<p>
An advantage of doing Bayesian analysis in <code>pymc</code> is that it has implemented the &ldquo;causal do&rdquo; operator. In the code below we first run a simulation with the baseline value for unmet, \(\upsilon\), which equals the sum of too expensive and other stated reasons why patient decided to forego treatment. The model estimates the fraction of people that forego treatment because it is too expensive as \(\zeta oop\). Hence, if \(oop\) is increased by \(\Delta oop\), the fraction of people skipping treatment because it is too expensive increases by \(\zeta \Delta oop\). This we add to the baseline value of \(\upsilon\) for the counterfactual simulation. 
</p>


<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">&#965;_baseline</span> = idata.posterior.&#965;.mean(axis=(0,1)).values
<span style="color: #e95678;">pov_no_missing</span> = idata.posterior.pov.mean(axis=(0,1)).values
<span style="color: #e95678;">zeta</span> = idata.posterior.&#950;.mean(axis=(0,1)).values
<span style="color: #e95678;">delta_oop</span> = 0.1
<span style="color: #e95678;">delta_&#964;</span> = zeta.reshape(1,2)*delta_oop
<span style="color: #e95678;">iota_0</span> = idata.posterior.&#953;_0.mean(axis=(0,1))[0].values
<span style="color: #e95678;">AR_model_0</span> = do(AR_model, {<span style="color: #fab795;">"&#965;"</span>: &#965;_baseline})
<span style="color: #e95678;">AR_model_1</span> = do(AR_model, {<span style="color: #fab795;">"&#965;"</span>: &#965;_baseline + delta_&#964;})
</pre>
</div>

<p>
Having defined the two models <code>AR_model_0, AR_model_1</code>, we sample from these models with the new values for unmet medical needs \(\upsilon\).
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">SEED</span>=44
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">Sample &#963; from baseline model
</span><span style="color: #e95678;">idata_0</span> = pm.sample_posterior_predictive(
    idata,
    model=AR_model_0,
    predictions=<span style="color: #f09383;">True</span>,
    var_names=[<span style="color: #fab795;">"&#963;"</span>,<span style="color: #fab795;">"ill"</span>],
    random_seed=SEED,
)
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">Sample new &#963; with higher oop
</span><span style="color: #e95678;">idata_1</span> = pm.sample_posterior_predictive(
    idata,
    model=AR_model_1,
    predictions=<span style="color: #f09383;">True</span>,
    var_names=[<span style="color: #fab795;">"&#963;"</span>,<span style="color: #fab795;">"ill"</span>],
    random_seed=SEED,
)

</pre>
</div>




<p>
We can save the posterior distributions of these (counter-factual) simulations.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">idata_0.to_netcdf(<span style="color: #fab795;">"./trace/baseline_model_do_0.nc"</span>)
idata_1.to_netcdf(<span style="color: #fab795;">"./trace/baseline_model_do_1.nc"</span>)
</pre>
</div>

<pre class="example">
./trace/baseline_model_do_1.nc
</pre>


<p>
And read in these trace files when we need them:
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">idata_0</span> = az.from_netcdf(<span style="color: #fab795;">"./trace/baseline_model_do_0.nc"</span>)
<span style="color: #e95678;">idata_1</span> = az.from_netcdf(<span style="color: #fab795;">"./trace/baseline_model_do_1.nc"</span>)
</pre>
</div>

<p>
In order to find the fractions of people who are ill and fit in these simulations, we need the parameters \(\pi,\delta\) and \(\sigma\) from the model. From these parameters, only \(\sigma\) differs between the baseline and the counterfactual simulation.
</p>

<p>
We want to project the effects for 40 years into the future and hence cannot use the year dimension in the model for \(\sigma\) (which is only 11 years). Therefore we take the latest year for \(\sigma\) as the most recent information for our simulations.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">pi</span> = idata.posterior.&#960;.values.transpose((2,3,4,5,0,1))[:,:,:,:,:,:]
<span style="color: #e95678;">delta</span> = idata.posterior.&#948;.values.transpose((2,3,4,5,6,0,1))[0]
<span style="color: #e95678;">sigma_0</span> = idata_0.predictions.&#963;.values.transpose((2,3,4,5,6,0,1))[-1] <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">use latest year
</span><span style="color: #e95678;">sigma_1</span> = idata_1.predictions.&#963;.values.transpose((2,3,4,5,6,0,1))[-1]
</pre>
</div>

<p>
Since we are interested in the dynamic effects of the change in oop, we consider the longest run that we have in the model: people who are 45 at the start of the simulation and we follow this cohort until they are 84.
</p>

<p>
In order to calculate/normalize the life years, we start with 1000 forty-five year olds per category gender/income and region. We use our estimate of \(\iota_0\) to split the 1000 individuals into fit and ill. Then we run through our Markov model keeping track of who switches health state and who dies. 
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">iota_0</span> = idata.posterior.&#953;_0.values.transpose((2,3,4,5,0,1))[0,<span style="color: #f09383;">None</span>,:,:,:,:,:]
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">outcomes baseline:
</span><span style="color: #e95678;">shape</span> = (2,n_ages,n_g,n_regions,n_y,4,2000) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit/ill, age, gender, region, income, chain, samples
</span><span style="color: #e95678;">N_0</span> = np.zeros(shape) 
<span style="color: #e95678;">N_0</span>[0,0] = (1-iota_0)*1000 <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit
</span><span style="color: #e95678;">N_0</span>[1,0] = iota_0*1000     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">ill
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">outcomes counterfactual:
</span><span style="color: #e95678;">N_1</span> = np.zeros(shape) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit/ill, age, gender, region, income, samples
</span><span style="color: #e95678;">N_1</span>[0,0] = (1-iota_0)*1000 <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit
</span><span style="color: #e95678;">N_1</span>[1,0] = iota_0*1000     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">ill
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">follow these 45 year olds till they are 85
</span><span style="color: #b877db;">for</span> j <span style="color: #b877db;">in</span> <span style="color: #b877db;">range</span>(1,n_ages):
   <span style="color: #e95678;">N_0</span>[0,j] = (1-pi[j-1])*N_0[0,j-1] + sigma_0 * N_0[1,j-1]
   <span style="color: #e95678;">N_0</span>[1,j] = pi[j-1]*N_0[0,j-1] + (1-sigma_0 - delta) * N_0[1,j-1] 
   <span style="color: #e95678;">N_1</span>[0,j] = (1-pi[j-1])*N_1[0,j-1] + sigma_1 * N_1[1,j-1]
   <span style="color: #e95678;">N_1</span>[1,j] = pi[j-1]*N_1[0,j-1] + (1-sigma_1 - delta) * N_1[1,j-1] 
</pre>
</div>

<p>
To calculate life years over the lifetime (from 45-84), we count a healthy life year as 1.0 and a life year while ill at <code>qaly_ill</code> and add these together. When someone dies, there are no life years left for this person (weight 0.0). The variable <code>delta_lifeyears</code> calculates the difference between life years in the baseline simulation and the counterfactual. We adjust the &rsquo;qaly&rsquo; for the ill to a value smaller than 1.0 to capture the idea that with a probability of dying above 10% per year (conditional on being ill) suggests that patients do face significant restrictions in daily life.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">qaly_ill</span> = 0.6
<span style="color: #e95678;">lifeyears_0</span> = N_0[0].<span style="color: #b877db;">sum</span>(axis=0) + qaly_ill*N_0[1].<span style="color: #b877db;">sum</span>(axis=0)
<span style="color: #e95678;">lifeyears_1</span> = N_1[0].<span style="color: #b877db;">sum</span>(axis=0) + qaly_ill*N_1[1].<span style="color: #b877db;">sum</span>(axis=0)
<span style="color: #e95678;">delta_lifeyears</span> = lifeyears_0 - lifeyears_1
</pre>
</div>

<p>
In order to summarize the results we present two qaly outcomes per country. The following code presents the unweighted average of regions into countries.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">lifeyears_per_country</span> = np.tensordot(country_region_matrix,lifeyears_0,axes=([1,1]))
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">index: country/gender/income/chain/samples</span>
</pre>
</div>

<p>
Plot qaly&rsquo;s for low income men and high income women.
</p>



<div class="org-src-container">
<pre class="src src-jupyter-python">
<span style="color: #e95678;">category_names</span> = [<span style="color: #fab795;">'qaly low income men'</span>, <span style="color: #fab795;">'qaly high income women'</span>]
<span style="color: #e95678;">labels</span> = countries

<span style="color: #e95678;">data</span> = np.stack((lifeyears_per_country.mean(axis=(3,4))[:,1,0],lifeyears_per_country.mean(axis=(3,4))[:,0,1]),axis=1)/40000
<span style="color: #e95678;">category_colors</span> = plt.get_cmap(<span style="color: #fab795;">'viridis'</span>)(
    np.linspace(0.15, 0.85, data.shape[1]))

fig, (<span style="color: #e95678;">ax1</span>,<span style="color: #e95678;">ax2</span>) = plt.subplots(1,2, figsize=(16, 6))
ax1.invert_yaxis()
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">ax.xaxis.set_visible(False)
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">ax.set_xlim(0, 1)
</span>ax1.set_title(<span style="color: #fab795;">"Fraction of max. qaly's realized for 45 year olds per country</span><span style="color: #f09383;">\n</span><span style="color: #fab795;">"</span>)

<span style="color: #b877db;">for</span> i, (colname, color) <span style="color: #b877db;">in</span> <span style="color: #b877db;">enumerate</span>(<span style="color: #b877db;">zip</span>(category_names, category_colors)):
    <span style="color: #e95678;">starts</span> = i * data[:,0]
    <span style="color: #e95678;">widths</span> = data[:, i] - starts
    ax1.barh(labels, widths, left = starts, height=0.5,
            label=colname, color=color)
    <span style="color: #e95678;">xcenters</span> = starts + widths / 2

    <span style="color: #e95678;">r</span>, <span style="color: #e95678;">g</span>, <span style="color: #e95678;">b</span>, <span style="color: #e95678;">_</span> = color
    <span style="color: #e95678;">text_color</span> = <span style="color: #fab795;">'white'</span> <span style="color: #b877db;">if</span> r * g * b &lt; 0.5 <span style="color: #b877db;">else</span> <span style="color: #fab795;">'darkgrey'</span>
    <span style="color: #b877db;">for</span> y, (x, c) <span style="color: #b877db;">in</span> <span style="color: #b877db;">enumerate</span>(<span style="color: #b877db;">zip</span>(xcenters, widths)):
        ax1.text(x, y, <span style="color: #fab795;">"{:.2f}"</span>.<span style="color: #b877db;">format</span>(c), ha=<span style="color: #fab795;">'center'</span>, va=<span style="color: #fab795;">'center'</span>,
                color=text_color)
ax1.legend(ncol=<span style="color: #b877db;">len</span>(category_names), bbox_to_anchor=(0, 1),
          loc=<span style="color: #fab795;">'lower left'</span>, fontsize=<span style="color: #fab795;">'small'</span>)


ax2.hist(delta_lifeyears[0,0,1].flatten(),bins=20,label=<span style="color: #fab795;">"high income, female"</span>,density=<span style="color: #f09383;">True</span>,alpha=0.5)
ax2.hist(delta_lifeyears[1,0,1].flatten(),bins=20,label=<span style="color: #fab795;">"high income, male"</span>,density=<span style="color: #f09383;">True</span>,alpha=0.5)
ax2.hist(delta_lifeyears[0,0,0].flatten(),bins=20,label=<span style="color: #fab795;">"low income, female"</span>,density=<span style="color: #f09383;">True</span>,alpha=0.5)
ax2.hist(delta_lifeyears[1,0,0].flatten(),bins=20,label=<span style="color: #fab795;">"low income, male"</span>,density=<span style="color: #f09383;">True</span>,alpha=0.5)
ax2.legend()
ax2.set_title(<span style="color: #fab795;">"Qaly's lost (per 1000 population) due to $oop$ increase by $0.1$"</span>);
</pre>
</div>


<div id="org7cc7f4a" class="figure">
<p><img src="./figures/summary_two_applications.png" alt="summary_two_applications.png" />
</p>
</div>




<p>
In order to compare the dynamic and static approach, use the ages 45-74 (first cohort at the start of our data; see the first row in Table <a href="#org6103c20">1</a>). Then we compare this with the dynamic estimate <code>delta_lifeyears</code> over the same age-range (that is, not the range 45-84 that we consider above).
</p>


<p>
The following code calculates the dynamic loss in life years from 45 to 74 and returns the data in the first row of Table <a href="#org3dd0539">3</a>:
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">lifeyears_0_d</span> = N_0[0,:30].<span style="color: #b877db;">sum</span>(axis=0) + qaly_ill*N_0[1,:30].<span style="color: #b877db;">sum</span>(axis=0)
<span style="color: #e95678;">lifeyears_1_d</span> = N_1[0,:30].<span style="color: #b877db;">sum</span>(axis=0) + qaly_ill*N_1[1,:30].<span style="color: #b877db;">sum</span>(axis=0)
<span style="color: #e95678;">delta_lifeyears_d</span> = lifeyears_0_d - lifeyears_1_d
delta_lifeyears_d.mean(axis=(1,3,4))
</pre>
</div>

<pre class="example">
array([[5.22867775, 0.45827571],
       [8.00927005, 0.82308271]])
</pre>


<p>
To find the static estimate, we do the following. For \(\iota_0\) we are only interested in the first year; hence, index 0 in the slicing of <code>ill</code> to get <code>ill_0</code>. We will compare the qaly&rsquo;s after 1 year of the introduction of \(\Delta oop\) with the counterfactual after 1 year without the increase in \(oop\). The latter is denoted <code>lifeyears_0_s</code> (with <code>s</code> for static) and the former <code>lifeyears_1_s</code>. The code returns the second row of Table <a href="#org3dd0539">3</a> (and repeats the first row for ease of reference).
</p>


<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">ill_0</span> = idata_0.predictions.ill.values[:,:,0,:,:,:,:].transpose((2,3,4,5,0,1))*1000
<span style="color: #e95678;">fit_0</span> = 1000-ill_0
<span style="color: #e95678;">fit_1_0</span> = (1-pi[:30])*fit_0 + sigma_0 * ill_0
<span style="color: #e95678;">ill_1_0</span> = pi[:30]*fit_0 + (1-sigma_0-delta) * ill_0
<span style="color: #e95678;">deaths_1_0</span> = delta * ill_1_0
<span style="color: #e95678;">lifeyears_0_s</span> = fit_1_0 + ill_1_0 * (1-delta) * qaly_ill
<span style="color: #e95678;">fit_1_1</span> = (1-pi[:30])*fit_0 + sigma_1 * ill_0
<span style="color: #e95678;">ill_1_1</span> = pi[:30]*fit_0 + (1-sigma_1-delta) * ill_0
<span style="color: #e95678;">deaths_1_1</span> = delta * ill_1_1
<span style="color: #e95678;">lifeyears_1_s</span> = fit_1_1 + ill_1_1 * (1-delta) * qaly_ill
<span style="color: #e95678;">delta_lifeyears_s</span> = (lifeyears_0_s - lifeyears_1_s).<span style="color: #b877db;">sum</span>(axis=0)
<span style="color: #b877db;">print</span>(<span style="color: #fab795;">"The qaly effect based on a one year (static) comparison:"</span>)
<span style="color: #b877db;">print</span>(delta_lifeyears_s.mean(axis=(1,3,4)))
<span style="color: #b877db;">print</span>(<span style="color: #fab795;">"The qaly effect based on a 30 year (dynamic) comparison:"</span>)
<span style="color: #b877db;">print</span>(delta_lifeyears_d.mean(axis=(1,3,4)))

</pre>
</div>

<pre class="example">
The qaly effect based on a one year (static) comparison:
[[0.24927238 0.05729696]
 [0.31104821 0.11820345]]
The qaly effect based on a 30 year (dynamic) comparison:
[[5.22867775 0.45827571]
 [8.00927005 0.82308271]]
</pre>
</div>
<div id="outline-container-org3cb10cd" class="outline-4">
<h4 id="org3cb10cd">sensitivity analysis \(\theta\)</h4>
<div class="outline-text-4" id="text-org3cb10cd">
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">iota_0</span> = idata.posterior.&#953;_0.values.transpose((2,3,4,5,0,1))[0,<span style="color: #f09383;">None</span>,:,:,:,:,:]
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">outcomes baseline:
</span><span style="color: #e95678;">shape</span> = (2,n_ages,n_g,n_regions,n_y,4,2000) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit/ill, age, gender, region, income, chain, samples
</span><span style="color: #e95678;">N_0</span> = np.zeros(shape) 
<span style="color: #e95678;">N_0</span>[0,0] = (1-iota_0)*1000 <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit
</span><span style="color: #e95678;">N_0</span>[1,0] = iota_0*1000     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">ill
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">outcomes counterfactual:
</span><span style="color: #e95678;">N_1</span> = np.zeros(shape) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit/ill, age, gender, region, income, samples
</span><span style="color: #e95678;">N_1</span>[0,0] = (1-iota_0)*1000 <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit
</span><span style="color: #e95678;">N_1</span>[1,0] = iota_0*1000     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">ill
</span><span style="color: #b877db;">for</span> j <span style="color: #b877db;">in</span> <span style="color: #b877db;">range</span>(1,n_ages):
   <span style="color: #e95678;">N_0</span>[0,j] = (1-pi[j-1])*N_0[0,j-1] + sigma_0 * N_0[1,j-1]
   <span style="color: #e95678;">N_0</span>[1,j] = pi[j-1]*N_0[0,j-1] + (1-sigma_0 - delta) * N_0[1,j-1] 
   <span style="color: #e95678;">N_1</span>[0,j] = (1-pi[j-1])*N_1[0,j-1] + sigma_1 * N_1[1,j-1]
   <span style="color: #e95678;">N_1</span>[1,j] = pi[j-1]*N_1[0,j-1] + (1-sigma_1 - delta) * N_1[1,j-1]

<span style="color: #e95678;">ill_0</span> = idata_0.predictions.ill.values[:,:,0,:,:,:,:].transpose((2,3,4,5,0,1))*1000
<span style="color: #e95678;">fit_0</span> = 1000-ill_0
<span style="color: #e95678;">fit_1_0</span> = (1-pi[:30])*fit_0 + sigma_0 * ill_0
<span style="color: #e95678;">ill_1_0</span> = pi[:30]*fit_0 + (1-sigma_0-delta) * ill_0
<span style="color: #e95678;">deaths_1_0</span> = delta * ill_1_0
</pre>
</div>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #b877db;">for</span> qaly_ill <span style="color: #b877db;">in</span> [0.3,0.6,0.8]:
    <span style="color: #e95678;">lifeyears_0_d</span> = N_0[0,:30].<span style="color: #b877db;">sum</span>(axis=0) + qaly_ill*N_0[1,:30].<span style="color: #b877db;">sum</span>(axis=0)
    <span style="color: #e95678;">lifeyears_1_d</span> = N_1[0,:30].<span style="color: #b877db;">sum</span>(axis=0) + qaly_ill*N_1[1,:30].<span style="color: #b877db;">sum</span>(axis=0)
    <span style="color: #e95678;">delta_lifeyears_d</span> = lifeyears_0_d - lifeyears_1_d
    <span style="color: #e95678;">lifeyears_0_s</span> = fit_1_0 + ill_1_0 * (1-delta) * qaly_ill
    <span style="color: #e95678;">fit_1_1</span> = (1-pi[:30])*fit_0 + sigma_1 * ill_0
    <span style="color: #e95678;">ill_1_1</span> = pi[:30]*fit_0 + (1-sigma_1-delta) * ill_0
    <span style="color: #e95678;">deaths_1_1</span> = delta * ill_1_1
    <span style="color: #e95678;">lifeyears_1_s</span> = fit_1_1 + ill_1_1 * (1-delta) * qaly_ill
    <span style="color: #e95678;">delta_lifeyears_s</span> = (lifeyears_0_s - lifeyears_1_s).<span style="color: #b877db;">sum</span>(axis=0)
    <span style="color: #b877db;">print</span>(<span style="color: #fab795;">"$</span><span style="color: #f09383;">\\</span><span style="color: #fab795;">theta= {}"</span>.<span style="color: #b877db;">format</span>(qaly_ill))
    <span style="color: #b877db;">print</span>(<span style="color: #fab795;">"------------------"</span>)
    <span style="color: #b877db;">print</span>(<span style="color: #fab795;">"The qaly effect based on a one year (static) comparison:"</span>)
    <span style="color: #b877db;">print</span>(delta_lifeyears_s.mean(axis=(1,3,4)))
    <span style="color: #b877db;">print</span>(<span style="color: #fab795;">"The qaly effect based on a 30 year (dynamic) comparison:"</span>)
    <span style="color: #b877db;">print</span>(delta_lifeyears_d.mean(axis=(1,3,4)))
    <span style="color: #b877db;">print</span>(<span style="color: #fab795;">"===================</span><span style="color: #f09383;">\n\n</span><span style="color: #fab795;">"</span>)
    
</pre>
</div>

<pre class="example" id="orge86001a">
$\theta= 0.3
------------------
The qaly effect based on a one year (static) comparison:
[[0.38902756 0.08950396]
 [0.4844081  0.18452225]]
The qaly effect based on a 30 year (dynamic) comparison:
[[6.26457103 0.55631355]
 [9.56168487 0.98269388]]
===================
$\theta= 0.6
------------------
The qaly effect based on a one year (static) comparison:
[[0.24927238 0.05729696]
 [0.31104821 0.11820345]]
The qaly effect based on a 30 year (dynamic) comparison:
[[5.22867775 0.45827571]
 [8.00927005 0.82308271]]
===================
$\theta= 0.8
------------------
The qaly effect based on a one year (static) comparison:
[[0.15610226 0.03582562]
 [0.19547495 0.07399091]]
The qaly effect based on a 30 year (dynamic) comparison:
[[4.53808223 0.39291715]
 [6.97432684 0.71667526]]
===================
</pre>
</div>
</div>
<div id="outline-container-orgbaf41ba" class="outline-4">
<h4 id="orgbaf41ba">comparison to (<a href="#citeproc_bib_item_4">Finkelstein and McKnight 2008</a>)</h4>
<div class="outline-text-4" id="text-orgbaf41ba">
<p>
As a final illustration of the difference between the dynamic and static estimates, consider (<a href="#citeproc_bib_item_4">Finkelstein and McKnight 2008</a>). We illustrate their estimate &#x2013;which we call static&#x2013; with our dynamic estimate using our framework of \(\Delta oop = 0.1\) instead of the introduction of Medicare that they actually analyse. Doing the comparison in our framework of \(\Delta oop\) makes it easier to understand this section in terms of the analysis we do above.
</p>

<p>
Hence, there are two differences:
</p>
<ul class="org-ul">
<li>we consider a change in oop instead of introducing a new insurance scheme and</li>
<li>in our case the reform is a reduction in insurance (increase in \(oop\)) instead of an expansion.</li>
</ul>

<p>
As explained in the main text, we do not need to compare 65-74 year olds with 55-64 year olds. As we simulate our model, we can compare 65-74 year olds both with and without the reform. Of course, their comparison is based on the DiD methodology and makes sense in their paper.
</p>

<p>
The following figure illustrates the intensity of treatment (how many years the agent faced the reform \(\Delta oop = 0.1\)) after 65. The horizontal black line shows the sample used by Finkelstein and McKnight (<a href="#citeproc_bib_item_4">2008</a>) to estimate the effect of the reform. The blue line illustrates our dynamic estimate. Clearly, the blue line touches intensities (above 75) that are not reached by the static estimate. The right panel shows that the dynamic effect above 80 is more than six times the static effect.
</p>

<p>
We calculate the effect for low income males in the first region of Bulgaria, <code>BG31</code>. We start at 65 (index 20) for \(\iota_0\) and \(\pi\). We derive the development of the number of ill and fit (starting with a normalized population of 1000) and calculate the difference in mortality.
</p>


<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">n_years</span> = 18
<span style="color: #e95678;">iota_0</span> = idata.posterior.&#953;_0.values.transpose((2,3,4,5,0,1))[20,1,0,0,:,:] <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">age 65 and higher
</span><span style="color: #e95678;">pi</span> = idata.posterior.&#960;.values.transpose((2,3,4,5,0,1))[20:,1,0,0,:,:]
<span style="color: #e95678;">delta</span> = idata.posterior.&#948;.values.transpose((2,3,4,5,6,0,1))[0][0,0,0,0]
<span style="color: #e95678;">sigma_0</span> = idata_0.predictions.&#963;.values.transpose((2,3,4,5,6,0,1))[-1][0,0,0,0]
<span style="color: #e95678;">sigma_1</span> = idata_1.predictions.&#963;.values.transpose((2,3,4,5,6,0,1))[-1][0,0,0,0]

<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">outcomes baseline:
</span><span style="color: #e95678;">shape</span> = (2,n_years,4,2000) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit/ill, year, chain, samples
</span><span style="color: #e95678;">N_0</span> = np.zeros(shape) 
<span style="color: #e95678;">N_0</span>[0,0] = (1-iota_0)*1000 <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit
</span><span style="color: #e95678;">N_0</span>[1,0] = iota_0*1000     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">ill
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;"># # outcomes counterfactual:
</span><span style="color: #e95678;">N_1</span> = np.zeros(shape) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit/ill, age, gender, region, income, samples
</span><span style="color: #e95678;">N_1</span>[0,0] = (1-iota_0)*1000 <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit
</span><span style="color: #e95678;">N_1</span>[1,0] = iota_0*1000     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">ill
</span><span style="color: #e95678;">a</span> = 0 <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">start from 65 year olds in year 0
</span><span style="color: #b877db;">for</span> y <span style="color: #b877db;">in</span> <span style="color: #b877db;">range</span>(1,n_years):
        <span style="color: #e95678;">N_0</span>[0,y] = (1-pi[y-1])*N_0[0,y-1] + sigma_0 * N_0[1,y-1]
        <span style="color: #e95678;">N_0</span>[1,y] = pi[y-1]*N_0[0,y-1] + (1-sigma_0 - delta) * N_0[1,y-1] 
        <span style="color: #e95678;">N_1</span>[0,y] = (1-pi[y-1])*N_1[0,y-1] + sigma_1 * N_1[1,y-1]
        <span style="color: #e95678;">N_1</span>[1,y] = pi[y-1]*N_1[0,y-1] + (1-sigma_1 - delta) * N_1[1,y-1]


<span style="color: #e95678;">mortality_difference</span> = delta*(N_1[1]/(N_1[0]+N_1[1])-N_0[1]/(N_0[0]+N_0[1]))
</pre>
</div>

<p>
The matrix <code>C</code> keeps track of the number of years that a given age/year combination has been exposed to the reform.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">n_ages</span>=19
<span style="color: #e95678;">C</span> = np.zeros([n_ages,n_ages])
<span style="color: #b877db;">for</span> c <span style="color: #b877db;">in</span> <span style="color: #b877db;">range</span>(n_ages):
    <span style="color: #b877db;">for</span> r <span style="color: #b877db;">in</span> <span style="color: #b877db;">range</span>(n_ages):
        <span style="color: #e95678;">C</span>[<span style="color: #e95678;">c</span>,<span style="color: #e95678;">r</span>] = <span style="color: #b877db;">min</span>(c,r)

</pre>
</div>

<p>
The left panel plots the treatment intensity as a function of age and years after the reform. The right panel shows the dynamic estimate normalized the mean mortality difference for ages 65-74. With this normalization, the static effect equals one.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">
fig, (<span style="color: #e95678;">ax1</span>,<span style="color: #e95678;">ax2</span>) = plt.subplots(1,2, figsize=(16, 6))


<span style="color: #b877db;">for</span> r <span style="color: #b877db;">in</span> <span style="color: #b877db;">range</span>(n_ages):
    ax1.scatter(r*np.ones(n_ages),<span style="color: #b877db;">range</span>(n_ages),c=C.T[r]/18.0,cmap=<span style="color: #fab795;">'YlGn'</span>,vmin=0.0,vmax=1.0)
    ax1.set_xticks(<span style="color: #b877db;">range</span>(n_ages),np.arange(n_ages)+65)
    ax1.set_yticks(<span style="color: #b877db;">range</span>(n_ages),np.arange(n_ages))
<span style="color: #e95678;">eps</span>=0.4
ax1.plot([0,18],[0-eps,18-eps])
ax1.plot([0,9],[10-eps,10-eps],c=<span style="color: #fab795;">'k'</span>)
ax1.set_xlabel(<span style="color: #fab795;">'age'</span>)
ax1.set_ylabel(<span style="color: #fab795;">'year'</span>)
ax1.set_title(<span style="color: #fab795;">'Treatment intensity of new policy affecting ages 65+</span><span style="color: #f09383;">\n</span><span style="color: #fab795;"> introduced in year 0'</span>)



ax2.plot(mortality_difference.mean(axis=(1,2))/mortality_difference[:9].mean(),label=<span style="color: #fab795;">'dynamic estimate'</span>)
ax2.plot([0,9],[1,1],c=<span style="color: #fab795;">'k'</span>,label = <span style="color: #fab795;">'static estimate'</span>)
ax2.set_xlabel(<span style="color: #fab795;">'age'</span>)
ax2.set_title(<span style="color: #fab795;">'Mortality effect of new policy affecting 65+ over time</span><span style="color: #f09383;">\n</span><span style="color: #fab795;"> relative to average effect for 65-74 year olds'</span>)
ax2.set_ylabel(<span style="color: #fab795;">'normalized mortality difference'</span>)
ax2.set_xticks(np.arange(18),np.arange(65,83))
ax2.legend();
</pre>
</div>


<div id="orge7473cc" class="figure">
<p><img src="./figures/years_treatment.png" alt="years_treatment.png" />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org03b6065" class="outline-2">
<h2 id="org03b6065"><span class="section-number-2">6.</span> Extensions</h2>
<div class="outline-text-2" id="text-6">
<p>
In this section, we present two robustness checks to validate our baseline results. First, we assess potential confounding from broader macroeconomic conditions and healthcare quality. As a placebo test, we examine whether oop payments predict traffic mortality &#x2013;a health outcome unlikely to be influenced by cost-sharing. We also augment the baseline model with GDP per capita. If the estimated effect of the variable <code>TooExp</code> (unmet medical need due to cost) were to vanish with GDP included, it would imply that cost-sharing is merely a proxy for recession-induced fiscal constraints. In that case, higher mortality would stem from reduced healthcare quality rather than forgone treatment. To further address this, we include an additional healthcare quality proxy &#x2013;the number of imaging devices per capita&#x2013; alongside infant mortality and physician density. We also add education and unemployment as variables capturing lifestyle choices in a region.
</p>

<p>
Finally, we test the sensitivity of our results to the choice of \(\theta\), the relative value of a life-year in poor health compared to full health, used in our qaly computations.
</p>
</div>
<div id="outline-container-org5f86cee" class="outline-3">
<h3 id="org5f86cee"><span class="section-number-3">6.1.</span> Data</h3>
<div class="outline-text-3" id="text-6-1">
<p>
For the extensions we use the variables in Table <a href="#org1ffa751">4</a> in addition to the variables in Table <a href="#orge5ea27f">2</a>. We have data on the number of people that die in traffic accidents. The unit is number of deaths per 1 million inhabitants of the region. We have data on GDP per capita (purchasing power standard) and the percentage of people unemployed in the region. We have the percentage of people (aged 25-64) with tertiary education in the region. We only have this from 2013 onward. Finally, we have data on the number of devices for medical imaging (MRI&rsquo;s, PET scanners etc.) per 100k inhabitants at the country level.<sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup>
</p>


<table id="org1ffa751" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 4:</span> Summary statistics variables for model extensions</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">count</th>
<th scope="col" class="org-right">mean</th>
<th scope="col" class="org-right">std</th>
<th scope="col" class="org-right">min</th>
<th scope="col" class="org-right">median</th>
<th scope="col" class="org-right">max</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">traffic mortality per 1m inhab.</td>
<td class="org-right">679</td>
<td class="org-right">66.2</td>
<td class="org-right">41</td>
<td class="org-right">6</td>
<td class="org-right">58</td>
<td class="org-right">254</td>
</tr>

<tr>
<td class="org-left">GDP per capita</td>
<td class="org-right">629</td>
<td class="org-right">23829.3</td>
<td class="org-right">11335.1</td>
<td class="org-right">6600</td>
<td class="org-right">21300</td>
<td class="org-right">59500</td>
</tr>

<tr>
<td class="org-left">unemployment (%)</td>
<td class="org-right">679</td>
<td class="org-right">9.7</td>
<td class="org-right">6.5</td>
<td class="org-right">1.8</td>
<td class="org-right">7.7</td>
<td class="org-right">31.6</td>
</tr>

<tr>
<td class="org-left">tertiary education (%)</td>
<td class="org-right">378</td>
<td class="org-right">31.4</td>
<td class="org-right">9.9</td>
<td class="org-right">16.4</td>
<td class="org-right">31.4</td>
<td class="org-right">54.7</td>
</tr>

<tr>
<td class="org-left">number imaging devices per 100k inhab.</td>
<td class="org-right">121</td>
<td class="org-right">40.7</td>
<td class="org-right">47</td>
<td class="org-right">0</td>
<td class="org-right">27.8</td>
<td class="org-right">205.7</td>
</tr>
</tbody>
</table>

<p>
On average 66 people per 1 million inhabitants die in traffics accidents per year. This ranges from six in one region/year combination to a maximum of 254 deaths. GDP per capita is on average 24k but ranges per region from 6600 to almost 60k. Unemployment is on average almost 10% and varies from less than 2% to more than 30%. Almost one third of the working population has tertiary education on average. This varies from 16% to more than half of the population. Finally, the number of imaging devises is on average 40 per 100k inhabitants but varies from no devices in one year for a country to more than 200.
</p>
</div>
</div>
<div id="outline-container-org01bc715" class="outline-3">
<h3 id="org01bc715"><span class="section-number-3">6.2.</span> Extension of the model</h3>
<div class="outline-text-3" id="text-6-2">
<p>
In the extension of the model, we adjust two parameters of the baseline model. First, in the equation for \(\pi\) we also include education and unemployment in the following way:
</p>
\begin{equation}
\pi e^{a_1 \text{education} + a_2 \text{unemployment}}
\end{equation}
<p>
That is, we multiply the expression for \(\pi\) in the baseline model by a multiplier depending on education and unemployment. With more people having finished tertiary education one may expect more healthy lifestyle choices. Unemployment with the implication of lower income may lead to stress and/or worse lifestyle choices as fresh vegetables and fruit and, say, a gym membership are expensive. With the multiplier we capture that the effect of education and unemployment is small if the probability of falling ill is small to start with, say at age 45. At age 60 when the probability of falling ill is higher, the effect of unemployment and education is higher.
</p>

<p>
Second, in the equation for the probability of recovery conditional on treatment, \(\lambda\), we add GDP per capita and the number of imaging devices as additional variables capturing healthcare quality. These variables we add in the same way as infant mortality and number of physicians in the baseline specification of \(\lambda\).
</p>

<p>
With the estimated extended model we can do the same analysis as with the baseline model. Our main result is that the dynamic estimates are an order of magnitude higher than the static estimates. By comparing Tables <a href="#org3ed607b">5</a> and <a href="#org3dd0539">3</a> we see that this result is robust to the addition of the variables. The mean values of qaly&rsquo;s lost for the different categories are similar for the base and extended models. To illustrate that the differences in average qaly&rsquo;s lost are not &ldquo;significant&rdquo;, Figure <a href="#org140c341">6</a> shows the posterior distributions for qaly&rsquo;s lost for the female, low income category. Indeed, these distributions are almost the same for the base and extended models. The same is true for the other gender/income categories.
</p>

<table id="org3ed607b" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 5:</span> Dynamic vs. static estimates of qaly&rsquo;s lost due to \(\Delta oop = 0.1\) in the extended model.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">male</th>
<th scope="col" class="org-right">female</th>
<th scope="col" class="org-right">male</th>
<th scope="col" class="org-right">female</th>
</tr>

<tr>
<th scope="col" class="org-left">estimate</th>
<th scope="col" class="org-right">low income</th>
<th scope="col" class="org-right">low income</th>
<th scope="col" class="org-right">high income</th>
<th scope="col" class="org-right">high income</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(Q_0 - Q_1\)</td>
<td class="org-right">7.07</td>
<td class="org-right">4.63</td>
<td class="org-right">0.74</td>
<td class="org-right">0.41</td>
</tr>

<tr>
<td class="org-left">\(\tilde Q_0 - \tilde Q_1\)</td>
<td class="org-right">0.28</td>
<td class="org-right">0.23</td>
<td class="org-right">0.11</td>
<td class="org-right">0.05</td>
</tr>
</tbody>
</table>


<div id="org140c341" class="figure">
<p><img src="./figures/lifeyears_comparison_extended.png" alt="lifeyears_comparison_extended.png" />
</p>
<p><span class="figure-number">Figure 6: </span>Comparison of the posterior distribution of qaly&rsquo;s lost for the base and extended models</p>
</div>
</div>
</div>
<div id="outline-container-org528add7" class="outline-3">
<h3 id="org528add7"><span class="section-number-3">6.3.</span> Placebo treatment</h3>
<div class="outline-text-3" id="text-6-3">
<p>
As a final check on our proposed causal mechanism, we add a placebo treatment. Instead of analyzing mortality linked to health, we analyze mortality due to traffic accidents. In the latter case there is neither the dynamic element of a health stock developing over time nor a role for out-of-pocket expenditure causing forgone treatments which may cause mortality. The details of the model are in the appendix.
</p>

<p>
The idea is that if out-of-pocket expenditure has a clear positive effect on traffic mortality, an alternative causal mechanism presents itself: the government&rsquo;s fiscal space has narrowed (e.g. due to a recession) which simultaneously causes the government to increase demand-side cost-sharing and reduce investments in healthcare. The reduction in these investments, reduces healthcare quality and this is the cause of increased mortality. An increase in traffic accidents is then caused by reduced investment in road safety.
</p>

<p>
We do not find such a clear relation between our \(oop\) variable and traffic mortality. In particular, we find a posterior mean for the effect of \(oop\) on traffic mortality of 0.35 with a (posterior) standard deviation of 0.60 which is almost twice as high. This suggests that the path from an increase in \(oop\) to forgone treatments because they are too expensive (for low incomes) to reduced health status and higher mortality is plausible.
</p>
</div>
</div>
<div id="outline-container-org9231d16" class="outline-3">
<h3 id="org9231d16"><span class="section-number-3">6.4.</span> Different qaly values</h3>
<div class="outline-text-3" id="text-6-4">
<p>
When evaluating the effect of an increase in oop, we use \(\theta=0.6\) in the qaly calculation &#x2013;see equation \eqref{org5faadf5}. Table <a href="#org3772e90">6</a> illustrates that our main results are not sensitive to this choice. The table reports qaly&rsquo;s lost (due to \(\Delta oop =0.1\)) for \(\theta=0.3\) and \(0.8\). The middle rows equal Table <a href="#org3dd0539">3</a> for ease of reference.
</p>

<p>
For each value of \(\theta\) we see that the effects are far bigger for low than for high incomes and the dynamic estimates are order of magnitude bigger than the static ones. Further, part of the effect on qaly&rsquo;s lost is &#x2013;next to higher mortality&#x2013; that more people are in the low health state compared to the baseline situation with lower \(oop\). When higher weight \(\theta\) is given to the low health state, the effect of \(\Delta oop\) is lower: the qaly penalty for being in the low state is reduced. Indeed, all entries in the table fall with \(\theta\).
</p>

<p>
Although the size of the effect varies, the main results are robust to the choice of \(\theta\).
</p>

<table id="org3772e90" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 6:</span> Dynamic vs. static estimates of qaly&rsquo;s lost due to \(\Delta oop = 0.1\) for different values of \(\theta\).</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">male</th>
<th scope="col" class="org-right">female</th>
<th scope="col" class="org-right">male</th>
<th scope="col" class="org-right">female</th>
</tr>

<tr>
<th scope="col" class="org-right">\(\theta\)</th>
<th scope="col" class="org-left">estimate</th>
<th scope="col" class="org-right">low income</th>
<th scope="col" class="org-right">low income</th>
<th scope="col" class="org-right">high income</th>
<th scope="col" class="org-right">high income</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0.3</td>
<td class="org-left">\(Q_0 - Q_1\)</td>
<td class="org-right">9.56</td>
<td class="org-right">6.26</td>
<td class="org-right">0.98</td>
<td class="org-right">0.56</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">\(\tilde Q_0 - \tilde Q_1\)</td>
<td class="org-right">0.48</td>
<td class="org-right">0.39</td>
<td class="org-right">0.18</td>
<td class="org-right">0.09</td>
</tr>

<tr>
<td class="org-right">0.6</td>
<td class="org-left">\(Q_0 - Q_1\)</td>
<td class="org-right">8.01</td>
<td class="org-right">5.23</td>
<td class="org-right">0.82</td>
<td class="org-right">0.46</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">\(\tilde Q_0 - \tilde Q_1\)</td>
<td class="org-right">0.31</td>
<td class="org-right">0.24</td>
<td class="org-right">0.12</td>
<td class="org-right">0.06</td>
</tr>

<tr>
<td class="org-right">0.8</td>
<td class="org-left">\(Q_0 - Q_1\)</td>
<td class="org-right">6.97</td>
<td class="org-right">4.54</td>
<td class="org-right">0.72</td>
<td class="org-right">0.39</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">\(\tilde Q_0 - \tilde Q_1\)</td>
<td class="org-right">0.20</td>
<td class="org-right">0.16</td>
<td class="org-right">0.07</td>
<td class="org-right">0.04</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org62320b8" class="outline-3">
<h3 id="org62320b8"><span class="section-number-3">6.5.</span> reading the data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></h3>
<div class="outline-text-3" id="text-6-5">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>extended-data</label><pre class="src src-jupyter-python" id="org680f9f9">&lt;&lt;code-preamble&gt;&gt;
&lt;&lt;code-data&gt;&gt;
&lt;&lt;code-selection&gt;&gt;
&lt;&lt;code-matrices&gt;&gt;
&lt;&lt;code-variables&gt;&gt;
&lt;&lt;code-cohorts&gt;&gt;
&lt;&lt;code-moments&gt;&gt;
<span style="color: #e95678;">ds_extension</span> = xr.open_dataset(<span style="color: #fab795;">"./data/extensions/extended_data.nc"</span>)
<span style="color: #e95678;">ds_m</span> = xr.merge([ds,ds_extension],join=<span style="color: #fab795;">"left"</span>)
<span style="color: #b877db;">def</span> <span style="color: #87ceeb;">standardize</span>(x):
    <span style="color: #b877db;">return</span> (x-np.nanmean(x))/np.nanstd(x)
<span style="color: #e95678;">Traffic_mortality</span> = ds_m.killed_per_million_inhabitants.where(ds_m.killed_per_million_inhabitants!=0).values.astype(<span style="color: #fab795;">'int'</span>)
<span style="color: #e95678;">GDP</span> = standardize(ds_m.GDP_per_capita_PPS.values)
<span style="color: #e95678;">Education</span> = standardize(ds_m.tertiary_education.values)
<span style="color: #e95678;">Devices</span> = standardize(ds_m.number_devices.values)
<span style="color: #e95678;">Unemployment</span> = standardize(ds_m.unemployment.values)
<span style="color: #e95678;">devices_country</span> = np.dot(ds_m.number_devices.values, country_region_matrix_01.T)
</pre>
</div>



<div class="org-src-container">
<pre class="src src-jupyter-python">
<span style="color: #e95678;">stat_list</span> = []
<span style="color: #b877db;">def</span> <span style="color: #87ceeb;">summary_statistics</span>(var,name,stat_list=stat_list):
   <span style="color: #b877db;">return</span>  stat_list.append([name,np.<span style="color: #b877db;">sum</span>(~np.isnan(var)),np.nanmean(var).<span style="color: #b877db;">round</span>(decimals=1),np.nanstd(var).<span style="color: #b877db;">round</span>(decimals=1),np.nanmin(var).<span style="color: #b877db;">round</span>(decimals=1),np.nanmedian(var).<span style="color: #b877db;">round</span>(decimals=1),np.nanmax(var).<span style="color: #b877db;">round</span>(decimals=1)])

<span style="color: #e95678;">variables</span> = [ds_m.killed_per_million_inhabitants, ds_m.GDP_per_capita_PPS, ds_m.unemployment, ds_m.tertiary_education, devices_country]

<span style="color: #e95678;">names</span> = [<span style="color: #fab795;">'traffic mortality per 1m inhab.'</span>, <span style="color: #fab795;">'GDP per capita'</span>, <span style="color: #fab795;">'unemployment (%)'</span>, <span style="color: #fab795;">'tertiary education (%)'</span>, <span style="color: #fab795;">'number imaging devices per 100k inhab. '</span>]
<span style="color: #b877db;">for</span> i <span style="color: #b877db;">in</span> <span style="color: #b877db;">range</span>(<span style="color: #b877db;">len</span>(variables)):
   summary_statistics(variables[i],names[i])

<span style="color: #e95678;">df</span> = pd.DataFrame(stat_list,columns= [<span style="color: #fab795;">''</span>,<span style="color: #fab795;">'count'</span>,<span style="color: #fab795;">'mean'</span>,<span style="color: #fab795;">'std'</span>,<span style="color: #fab795;">'min'</span>,<span style="color: #fab795;">'median'</span>,<span style="color: #fab795;">'max'</span>])

<span style="color: #e95678;">headers</span> = [<span style="color: #fab795;">'count'</span>,<span style="color: #fab795;">'mean'</span>,<span style="color: #fab795;">'std'</span>,<span style="color: #fab795;">'min'</span>,<span style="color: #fab795;">'median'</span>,<span style="color: #fab795;">'max'</span>]

<span style="color: #b877db;">print</span>(tabulate(df,headers,tablefmt=<span style="color: #fab795;">"orgtbl"</span>,\
               colalign=(<span style="color: #fab795;">"left"</span>,<span style="color: #fab795;">"left"</span>, <span style="color: #fab795;">"right"</span>, <span style="color: #fab795;">"right"</span>, <span style="color: #fab795;">"right"</span>, <span style="color: #fab795;">"right"</span>, <span style="color: #fab795;">"right"</span>, <span style="color: #fab795;">"right"</span>)))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">count</th>
<th scope="col" class="org-right">mean</th>
<th scope="col" class="org-right">std</th>
<th scope="col" class="org-right">min</th>
<th scope="col" class="org-right">median</th>
<th scope="col" class="org-right">max</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">traffic mortality per 1m inhab.</td>
<td class="org-right">679</td>
<td class="org-right">66.2</td>
<td class="org-right">41</td>
<td class="org-right">6</td>
<td class="org-right">58</td>
<td class="org-right">254</td>
</tr>

<tr>
<td class="org-left">GDP per capita</td>
<td class="org-right">629</td>
<td class="org-right">23829.3</td>
<td class="org-right">11335.1</td>
<td class="org-right">6600</td>
<td class="org-right">21300</td>
<td class="org-right">59500</td>
</tr>

<tr>
<td class="org-left">unemployment (%)</td>
<td class="org-right">679</td>
<td class="org-right">9.7</td>
<td class="org-right">6.5</td>
<td class="org-right">1.8</td>
<td class="org-right">7.7</td>
<td class="org-right">31.6</td>
</tr>

<tr>
<td class="org-left">tertiary education (%)</td>
<td class="org-right">378</td>
<td class="org-right">31.4</td>
<td class="org-right">9.9</td>
<td class="org-right">16.4</td>
<td class="org-right">31.4</td>
<td class="org-right">54.7</td>
</tr>

<tr>
<td class="org-left">number imaging devices per 100k inhab.</td>
<td class="org-right">121</td>
<td class="org-right">40.7</td>
<td class="org-right">47</td>
<td class="org-right">0</td>
<td class="org-right">27.8</td>
<td class="org-right">205.7</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org6abf9b5" class="outline-3">
<h3 id="org6abf9b5"><span class="section-number-3">6.6.</span> extended model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></h3>
<div class="outline-text-3" id="text-6-6">
<p>
We extend the model with 4 variables: per capita GDP per NUTS 2 region, number of devices for medical imaging per 100k inhabitants at the country level, fraction of NUTS 2 inhabitants aged 25-64 who completed tertiary education and unemployment at the NUTS 2 level. The extended model is meant as a robustness check on the causal mechanism where OOP is increased, more people forgo treatment because it is too expensive and this has a negative effect on health.
</p>

<p>
An alternative interpretation of the negative effect of OOP on health is via the fiscal position of the government: as the government faces deficits, it increases OOP and reduces investment in healthcare quality. This reduction in quality is what is causing the drop in health not so much the forgone treatments. Unemployment and GDP per capita captures the fiscal position. The medical imaging devices (next to infant mortality and number of doctors) captures the quality of healthcare. Education captures knowledge about healthy lifestyles but also the wealth of the region. If more people with tertiary education immigrate to the region, its income will increase and the fiscal position will improve.
</p>

<p>
We model this as follows. We add education and unemployment as a multiplier to \(\pi\):
</p>
\begin{equation}
\label{orgc357b92}
\pi e^{a_1 \text{education} + a_2 \text{unemployment}}
\end{equation}
<p>
where the variables are normalized with expectation zero and standard deviation one. Hence, if education and unemployment are at their expected value, then the multiplier is equal to one. It is only when we variables are not equals to their expectation, the value of \(\pi\) is modified. If for, say, an age \(\pi\) is close to zero, then the multiplier has hardly an effect. Only when \(\pi\) is relatively big, does the multiplier have an impact. The variables GDP per capita and the number of imaging devices is added to the other &ldquo;health quality variables&rdquo; (infant mortality, number of physicians) in the expression for \(\lambda\).
</p>

<p>
Another advantage of standardizing the new variables is that when modelling the missing values they have mean zero and standard deviation one. Further, the variables are based on addition (number of unemployed, people with tertiary education and number of devices; sum of value added in the region) and the central limit theorem suggests a normal distribution for these variables.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span>code-extended-model</label><pre class="src src-jupyter-python" id="orgce68263"><span style="color: #b877db;">def</span> <span style="color: #87ceeb;">transition</span>(&#960;,&#963;,I,&#948;):
    <span style="color: #e95678;">fit</span> = I*&#963;+(1-&#960;)*(1-I)
    <span style="color: #e95678;">ill</span> = &#960;*(1-I)+pt.clip(1-&#963;-&#948;,0.0,1.0)*I
    <span style="color: #e95678;">fraction_ill</span> = ill/(fit+ill)
    <span style="color: #b877db;">return</span> fraction_ill

<span style="color: #e95678;">n_y</span> = 2 <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">low/high income
</span><span style="color: #e95678;">n_g</span> = 2 <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">female/male
</span><span style="color: #e95678;">countries</span> = np.array([<span style="color: #fab795;">'Bulgaria'</span>, <span style="color: #fab795;">'Switzerland'</span>, <span style="color: #fab795;">'Denmark'</span>, <span style="color: #fab795;">'Greece'</span>, <span style="color: #fab795;">'Finland'</span>, <span style="color: #fab795;">'Hungary'</span>, <span style="color: #fab795;">'Lithuania'</span>, <span style="color: #fab795;">'Norway'</span>, <span style="color: #fab795;">'Sweden'</span>, <span style="color: #fab795;">'Slovenia'</span>, <span style="color: #fab795;">'Slovakia'</span>])
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">index: age, gender, year, region, income
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">for some variables we use country instead of region
</span>
<span style="color: #e95678;">coords</span> = {
    <span style="color: #fab795;">"region"</span> : ds.nuts2.values,\
    <span style="color: #fab795;">"ages"</span> : ds.age.values,\
    <span style="color: #fab795;">"cohort"</span> : age_matrix[0],\
    <span style="color: #fab795;">"gender"</span> : ds.sex.values,\
    <span style="color: #fab795;">"year"</span> : ds.year.values,\
    <span style="color: #fab795;">"income"</span> : [<span style="color: #fab795;">'y_l'</span>,<span style="color: #fab795;">'y_h'</span>],\
    <span style="color: #fab795;">"country"</span>: countries,\
     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">we define dummy dimensions for parameters that do not
</span>     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">vary by this dimension
</span>     <span style="color: #fab795;">"dummy0"</span>: np.arange(1),\
     <span style="color: #fab795;">"dummy1"</span>: np.arange(1),\
     <span style="color: #fab795;">"dummy2"</span>: np.arange(1)}

<span style="color: #b877db;">with</span> pm.Model(coords=coords) <span style="color: #b877db;">as</span> extension_model:
    <span style="color: #e95678;">logodds_&#953;</span> = pm.Normal(<span style="color: #fab795;">"logodds_&#953;"</span>,-4.0,1,\
              dims=(<span style="color: #fab795;">"cohort"</span>,<span style="color: #fab795;">"gender"</span>,<span style="color: #fab795;">"region"</span>,<span style="color: #fab795;">"income"</span>),\
              shape=(cohorts,n_g,n_regions,n_y)) 
    <span style="color: #e95678;">&#953;_0</span> = pm.Deterministic(<span style="color: #fab795;">"&#953;_0"</span>,pm.math.invlogit(logodds_&#953;),dims=(<span style="color: #fab795;">"cohort"</span>,<span style="color: #fab795;">"gender"</span>,<span style="color: #fab795;">"region"</span>,<span style="color: #fab795;">"income"</span>))
    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">&#953;_0 is used to start the sequence in scan =&gt;
</span>    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">no need to add age dimension: we build up the matrix I by following each cohort over the years
</span>    <span style="color: #e95678;">logodds_&#948;</span> = pm.Normal(<span style="color: #fab795;">"logodds_&#948;"</span>,-2.5,0.05,dims=(<span style="color: #fab795;">"country"</span>)) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">conditional on being ill, same prob. of death
</span>    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">&#948; is a non_sequence in the scan loop; no need to add age as a dimension
</span>    <span style="color: #e95678;">&#948;</span> = pm.Deterministic(<span style="color: #fab795;">"&#948;"</span>,pt.dot(pm.math.invlogit(logodds_&#948;), country_region_matrix_01)[<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>,:,<span style="color: #f09383;">None</span>])
    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">new variables for the extension
</span>    <span style="color: #e95678;">gdp</span> = pm.Normal(<span style="color: #fab795;">'gdp'</span>,observed=GDP,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>))
    <span style="color: #e95678;">devices</span> = pm.Normal(<span style="color: #fab795;">'devices'</span>,observed=Devices,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>))
    <span style="color: #e95678;">education</span> = pm.Normal(<span style="color: #fab795;">'education'</span>,observed=Education,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>))
    <span style="color: #e95678;">unemployment</span> = pm.Normal(<span style="color: #fab795;">'unemployment'</span>,observed=Unemployment,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>))
        
    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">we build up the prior for &#960;
</span>    <span style="color: #4e5059; font-style: italic;">## </span><span style="color: #4e5059; font-style: italic;">this forms the multiplier used in the scan-method below
</span>    <span style="color: #e95678;">a1</span> = pm.Normal(<span style="color: #fab795;">"a1"</span>,0,0.01)
    <span style="color: #e95678;">a2</span> = pm.Normal(<span style="color: #fab795;">"a2"</span>,0,0.01)
    <span style="color: #e95678;">mult_pi</span> = np.exp(a1 * education + a2 * unemployment)
    <span style="color: #4e5059; font-style: italic;">## </span><span style="color: #4e5059; font-style: italic;">building &#960; from the logodds
</span>    <span style="color: #e95678;">logodds_age_&#960;</span> = pm.Normal(<span style="color: #fab795;">"logodds_age_&#960;"</span>,log_odds_mort.mean(axis=(1,2,3)),log_odds_mort.std(axis=(1,2,3)),dims=(<span style="color: #fab795;">"ages"</span>))
    <span style="color: #e95678;">logodds_sex_&#960;</span> = pm.Normal(<span style="color: #fab795;">"logodds_sex_&#960;"</span>, gender_effect_&#960;, 0.05, dims=(<span style="color: #fab795;">"gender"</span>))
    <span style="color: #e95678;">logodds_country_&#960;</span> = pm.Normal(<span style="color: #fab795;">"logodds_country_&#960;"</span>,country_effect_&#960;,0.05, dims=(<span style="color: #fab795;">"country"</span>))
    <span style="color: #e95678;">logodds_&#960;</span> = pm.Deterministic(<span style="color: #fab795;">"logodds_&#960;"</span>,logodds_age_&#960;[:,<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>] + logodds_sex_&#960;[<span style="color: #f09383;">None</span>,:,<span style="color: #f09383;">None</span>] +\
                                 pt.dot(logodds_country_&#960;, country_region_matrix_01)[<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>,:])
    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">the priors do not impose that women tend to be healthier than men
</span>    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">but we do impose that people on low income tend to have low health status (high &#960;)
</span>    <span style="color: #e95678;">delta_&#960;</span> = pm.HalfNormal(<span style="color: #fab795;">"delta_&#960;"</span>,sigma=0.05,\
          dims=(<span style="color: #fab795;">"ages"</span>,<span style="color: #fab795;">"dummy0"</span>,<span style="color: #fab795;">"dummy1"</span>),\
          shape=(n_ages,1,1))
    <span style="color: #e95678;">&#960;</span> = pm.Deterministic(<span style="color: #fab795;">"&#960;"</span>,pt.stack([pm.math.invlogit(\
                                    logodds_&#960;+ delta_&#960;),\
                   pm.math.invlogit(logodds_&#960;)],axis=-1), dims=(<span style="color: #fab795;">"ages"</span>,<span style="color: #fab795;">"gender"</span>,<span style="color: #fab795;">"region"</span>,<span style="color: #fab795;">"income"</span>))
    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">when we draw missing values for OOP, we should draw the same value for all regions/age/gender in the same country
</span>    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">this we do via oop_c which we later bring back to region dimension with country_region_matrix_01
</span>    <span style="color: #e95678;">pov</span> = pm.Normal(<span style="color: #fab795;">"pov"</span>, mean_depr[<span style="color: #f09383;">None</span>,:], std_depr[<span style="color: #f09383;">None</span>,:], observed=Deprivation,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>)) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fraction of people on low income
</span>    <span style="color: #e95678;">poverty</span> = pt.stack([pt.clip(pov,0,1),1-pt.clip(pov,0,1)],axis=-1) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">vector with fraction of low/high income people
</span>    <span style="color: #e95678;">oop_c</span> = pm.Normal(<span style="color: #fab795;">"oop_c"</span>, mean_oop_c[<span style="color: #f09383;">None</span>,:], std_oop_c[<span style="color: #f09383;">None</span>,:], observed=OOP_c,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"country"</span>))
    <span style="color: #e95678;">oop</span> = pt.dot(oop_c,country_region_matrix_01)

    <span style="color: #e95678;">slope_&#950;</span> = pm.HalfNormal(<span style="color: #fab795;">"slope_&#950;"</span>,sigma=0.05)
    <span style="color: #e95678;">delta_&#950;</span> = pm.HalfNormal(<span style="color: #fab795;">"delta_&#950;"</span>,sigma=0.05)
    <span style="color: #e95678;">&#950;</span> = pm.Deterministic(<span style="color: #fab795;">"&#950;"</span>,pt.stack([(slope_&#950;+ delta_&#950;),\
                   (slope_&#950;)],axis=-1),dims=(<span style="color: #fab795;">"income"</span>)) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">varies with income
</span>    <span style="color: #e95678;">&#964;</span> = pm.Deterministic(<span style="color: #fab795;">"&#964;"</span>, &#950;[<span style="color: #f09383;">None</span>,:]*oop[:,:,<span style="color: #f09383;">None</span>])
    <span style="color: #e95678;">mu_U_o</span> = Unmet_o.mean(axis=0).values[<span style="color: #f09383;">None</span>,:]
    <span style="color: #e95678;">nu_U_o</span> = pm.Exponential(<span style="color: #fab795;">"nu_U_o"</span>, 0.05)
    <span style="color: #e95678;">U_o</span> = pm.Beta(<span style="color: #fab795;">"U_o"</span>, alpha = mu_U_o*nu_U_o, beta = (1-mu_U_o)*nu_U_o,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>), observed=Unmet_o)
    <span style="color: #e95678;">mu_U</span> = pt.clip(U_o+pt.<span style="color: #b877db;">sum</span>(poverty*&#964;,axis=2),0.000001,0.9999)
    <span style="color: #e95678;">nu_U</span> = pm.Exponential(<span style="color: #fab795;">"nu_U"</span>, 0.05)
    <span style="color: #e95678;">U</span> = pm.Beta(<span style="color: #fab795;">"U"</span>,alpha=mu_U*nu_U, beta=(1-mu_U)*nu_U,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>), observed=Unmet)
    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">&#955; measures prob. patient heals if treated (i.e. one minus unmet)
</span>    <span style="color: #e95678;">M_infant</span> = pm.Normal(<span style="color: #fab795;">"M_infant"</span>,mean_m_infant[<span style="color: #f09383;">None</span>,:],std_m_infant[<span style="color: #f09383;">None</span>,:],dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>),observed=m_infant)
    <span style="color: #e95678;">Physicians</span> = pm.Normal(<span style="color: #fab795;">"Physicians"</span>,mean_physician[<span style="color: #f09383;">None</span>,:],std_physician[<span style="color: #f09383;">None</span>,:],dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>),observed=physicians)
    <span style="color: #e95678;">lambda_1</span> = pm.HalfNormal(<span style="color: #fab795;">"lambda_1"</span>,sigma=0.01)
    <span style="color: #e95678;">lambda_2</span> = pm.HalfNormal(<span style="color: #fab795;">"lambda_2"</span>,sigma=0.01)
    <span style="color: #e95678;">lambda_3</span> = pm.HalfNormal(<span style="color: #fab795;">"lambda_3"</span>,sigma=0.01)
    <span style="color: #e95678;">lambda_4</span> = pm.HalfNormal(<span style="color: #fab795;">"lambda_4"</span>,sigma=0.01)
    <span style="color: #e95678;">lamba_0</span> = pm.Normal(<span style="color: #fab795;">"lambda_0"</span>,-4.1,0.05,dims=(<span style="color: #fab795;">"year"</span>))
    <span style="color: #e95678;">logodds_&#955;</span> = pm.Normal(<span style="color: #fab795;">"logodds_&#955;"</span>,lamba_0[:,<span style="color: #f09383;">None</span>] - lambda_1 * M_infant + lambda_2 * Physicians + lambda_3 * gdp + lambda_4 * devices,0.1)
    <span style="color: #e95678;">&#955;</span> = pm.Deterministic(<span style="color: #fab795;">"&#955;"</span>,pm.math.invlogit(logodds_&#955;))<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">&#955; is between 0 and 1
</span>    <span style="color: #e95678;">&#949;</span> = pm.Beta(<span style="color: #fab795;">"&#949;"</span>,1,3) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">&#949; = &#958;_l - &#958;_h &gt; 0
</span>    <span style="color: #e95678;">&#958;</span> = 1-poverty[:,:,0]*&#949;
    <span style="color: #e95678;">&#965;</span> = pm.Deterministic(<span style="color: #fab795;">"&#965;"</span>, pt.stack([(&#958;+&#949;)*U_o,&#958;*U_o],axis=-1) + &#964;)
    <span style="color: #e95678;">&#963;_0</span> = pm.Beta(<span style="color: #fab795;">"&#963;_0"</span>,1,3)
    <span style="color: #e95678;">&#963;</span> = pm.Deterministic(<span style="color: #fab795;">"&#963;"</span>,pt.clip(&#963;_0+&#955;[:,<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>,:,<span style="color: #f09383;">None</span>]*(1-&#965;)[:,<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>,:,:],0,1))
    <span style="color: #e95678;">I</span> = pt.zeros((t_dim,cohorts,n_g,n_regions,n_y))
    <span style="color: #e95678;">I</span> = pt.set_subtensor(I[0],&#953;_0)

    <span style="color: #e95678;">outputs</span>, <span style="color: #e95678;">updates</span> = pytensor.scan(
        transition,
     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">age/year is the dynamic part of the model
</span>     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">i.e. first dimension of &#960;; not multiplied by the muliplier mult_pi defined above
</span>        sequences=[<span style="color: #b877db;">dict</span>(<span style="color: #b877db;">input</span>=&#960;[age_indices]*mult_pi[:,<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>,:,<span style="color: #f09383;">None</span>]),<span style="color: #b877db;">dict</span>(<span style="color: #b877db;">input</span>=&#963;)], <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">check sequences with order of arguments in =transition=
</span>     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">we loop over the first dimension: age
</span>     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">the initial value for I (at low_age)
</span>     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">outputs_info has no age dimension
</span>        outputs_info=[<span style="color: #b877db;">dict</span>(initial=&#953;_0)],
     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">variables that have no age dimension:
</span>        non_sequences=[&#948;[0]],
    )

    <span style="color: #e95678;">I</span> = pt.set_subtensor(I[1:],outputs[:t_dim-1])
    <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">&#956; is probability of death for age/gender/year/region
</span>    <span style="color: #e95678;">ill</span> = pm.Deterministic(<span style="color: #fab795;">"ill"</span>,I)
    <span style="color: #e95678;">&#956;</span> = pm.Deterministic(<span style="color: #fab795;">"&#956;"</span>,(pt.<span style="color: #b877db;">sum</span>(&#948;*I*poverty[:,<span style="color: #f09383;">None</span>,<span style="color: #f09383;">None</span>,:,:],axis=4)))<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">aggregate over income
</span>    <span style="color: #e95678;">mortality</span> = pm.Binomial(<span style="color: #fab795;">"mortality"</span>,n=P_cohort,p=&#956;,observed=M_cohort,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"cohort"</span>,<span style="color: #fab795;">"gender"</span>,<span style="color: #fab795;">"region"</span>))

</pre>
</div>
</div>
<div id="outline-container-org9b37aed" class="outline-4">
<h4 id="org9b37aed">sampling</h4>
<div class="outline-text-4" id="text-org9b37aed">
<p>
In order to sample from the posterior distribution of our parameters, we call all relevant code blocks above and sample using the Markov Chain Monte Carlo NUTS sampler.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">&lt;&lt;extended-data&gt;&gt;
&lt;&lt;code-extended-model&gt;&gt;
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">with extension_model:
</span><span style="color: #4e5059; font-style: italic;">#     </span><span style="color: #4e5059; font-style: italic;">idata_extended = pm.sample(draws=2000,target_accept = 0.95)
</span><span style="color: #4e5059; font-style: italic;">#     </span><span style="color: #4e5059; font-style: italic;">pm.sample_posterior_predictive(idata_extended,\
</span><span style="color: #4e5059; font-style: italic;">#                                    </span><span style="color: #4e5059; font-style: italic;">extend_inferencedata=True)
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">idata_extended.to_netcdf("./trace/extended_model.nc")</span>
</pre>
</div>


<p>
Reading in the samples when we do not run the MCMC sampler.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">idata_extended</span> = az.from_netcdf(<span style="color: #fab795;">"./trace/extended_model.nc"</span>)
</pre>
</div>


<p>
For the parameters where we do not have (too) many indices, we can summarize the results both in a table and with trace plots.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">pd.set_option(<span style="color: #fab795;">'display.max_rows'</span>, 75)

<span style="color: #e95678;">headers</span> = [<span style="color: #fab795;">'mean'</span>, <span style="color: #fab795;">'sd'</span>, <span style="color: #fab795;">'hdi_3%'</span>, <span style="color: #fab795;">'hdi_97%'</span>,\
           <span style="color: #fab795;">'ess_bulk'</span>, <span style="color: #fab795;">'r_hat'</span>]
<span style="color: #e95678;">variables</span> = [<span style="color: #fab795;">"logodds_sex_&#960;"</span>,<span style="color: #fab795;">"&#950;"</span>,<span style="color: #fab795;">"nu_U"</span>,<span style="color: #fab795;">"nu_U_o"</span>,<span style="color: #fab795;">"&#949;"</span>,<span style="color: #fab795;">"lambda_1"</span>,<span style="color: #fab795;">"lambda_2"</span>,<span style="color: #fab795;">"lambda_3"</span>,<span style="color: #fab795;">"lambda_4"</span>,<span style="color: #fab795;">"a1"</span>,<span style="color: #fab795;">"a2"</span>]
<span style="color: #e95678;">df_summary</span> = az.summary(idata_extended,var_names=variables)[headers]
<span style="color: #b877db;">print</span>(tabulate(df_summary,\
               headers,tablefmt=<span style="color: #fab795;">'orgtbl'</span>,floatfmt=<span style="color: #fab795;">".2f"</span>))
</pre>
</div>

<pre class="example" id="org3f23ecf">
|                  |   mean |    sd |   hdi_3% |   hdi_97% |   ess_bulk |   r_hat |
|------------------+--------+-------+----------+-----------+------------+---------|
| logodds_sex_π[F] |  -0.20 |  0.03 |    -0.26 |     -0.14 |     446.00 |    1.01 |
| logodds_sex_π[M] |   0.49 |  0.03 |     0.43 |      0.55 |     454.00 |    1.01 |
| ζ[y_l]           |   0.27 |  0.01 |     0.25 |      0.30 |    7970.00 |    1.00 |
| ζ[y_h]           |   0.03 |  0.00 |     0.03 |      0.04 |    6982.00 |    1.00 |
| nu_U             | 298.83 | 19.01 |   264.80 |    335.48 |    8188.00 |    1.00 |
| nu_U_o           | 111.82 |  6.59 |    99.33 |    124.10 |    7705.00 |    1.00 |
| ε                |   0.10 |  0.09 |     0.00 |      0.27 |   11795.00 |    1.00 |
| lambda_1         |   0.01 |  0.01 |     0.00 |      0.02 |    6864.00 |    1.00 |
| lambda_2         |   0.00 |  0.00 |     0.00 |      0.01 |    5025.00 |    1.00 |
| lambda_3         |   0.02 |  0.01 |     0.00 |      0.03 |    1239.00 |    1.00 |
| lambda_4         |   0.03 |  0.01 |     0.01 |      0.04 |    1467.00 |    1.00 |
| a1               |  -0.07 |  0.00 |    -0.08 |     -0.07 |    6351.00 |    1.00 |
| a2               |   0.01 |  0.00 |     0.00 |      0.02 |    4558.00 |    1.00 |
</pre>

<p>
These parameters are very similar to the baseline outcomes.
</p>

<p>
Also the trace plots are similar.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">plt.<span style="color: #e95678;">rcParams</span>[<span style="color: #fab795;">'figure.constrained_layout.use'</span>] = <span style="color: #f09383;">True</span>
az.plot_trace(idata_extended,var_names=variables);
</pre>
</div>


<div id="orgb2a370c" class="figure">
<p><img src="./figures/trace_extended.png" alt="trace_extended.png" />
</p>
</div>

<p>
The fit of the model is very similar to the baseline model as well.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">predictions</span> = idata_extended.posterior_predictive.mortality.\
              mean(dim=(<span style="color: #fab795;">"chain"</span>,<span style="color: #fab795;">"draw"</span>)).values
<span style="color: #e95678;">perc_predictions</span> = np.percentile(idata_extended.posterior_predictive.mortality.values,q=[2.5,97.5],axis=(0,1))
plt.vlines(M_cohort,perc_predictions[0],perc_predictions[1],color=<span style="color: #fab795;">'grey'</span>,linestyles=<span style="color: #fab795;">"dashed"</span>,linewidth=1,label=<span style="color: #fab795;">"95% interval"</span>,alpha=0.4)
plt.scatter((M_cohort),(predictions))
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">plt.scatter((M/Population).flatten(),(predictions/Population).flatten())
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">plt.plot([0,0.2],[0,0.2],c='k')
</span>plt.plot([0,860],[0,860],c=<span style="color: #fab795;">'k'</span>)
plt.legend()
plt.xlabel(<span style="color: #fab795;">"number of deaths"</span>)
plt.ylabel(<span style="color: #fab795;">"predicted number of deaths"</span>);
</pre>
</div>


<div id="orga0ac260" class="figure">
<p><img src="./figures/fit_extended_model.png" alt="fit_extended_model.png" />
</p>
</div>

<p>
Our main result is that a change in OOP has a far bigger (dynamic) effect that the static estimate would suggest. We replicate this for the extended model as well. 
</p>




<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">&#965;_baseline</span> = idata_extended.posterior.&#965;.mean(axis=(0,1)).values
<span style="color: #e95678;">pov_no_missing</span> = idata_extended.posterior.pov.mean(axis=(0,1)).values
<span style="color: #e95678;">zeta</span> = idata_extended.posterior.&#950;.mean(axis=(0,1)).values
<span style="color: #e95678;">delta_oop</span> = 0.1
<span style="color: #e95678;">delta_&#964;</span> = zeta.reshape(1,2)*delta_oop
<span style="color: #e95678;">iota_0</span> = idata_extended.posterior.&#953;_0.mean(axis=(0,1))[0].values
<span style="color: #e95678;">AR_model_0</span> = do(AR_model, {<span style="color: #fab795;">"&#965;"</span>: &#965;_baseline})
<span style="color: #e95678;">AR_model_1</span> = do(AR_model, {<span style="color: #fab795;">"&#965;"</span>: &#965;_baseline + delta_&#964;})
</pre>
</div>

<p>
We can save the posterior distributions of these (counter-factual) simulations.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">SEED</span>=44
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">Sample &#963; from baseline model
</span><span style="color: #e95678;">idata_extended_0</span> = pm.sample_posterior_predictive(
    idata_extended,
    model=AR_model_0,
    predictions=<span style="color: #f09383;">True</span>,
    var_names=[<span style="color: #fab795;">"&#963;"</span>,<span style="color: #fab795;">"ill"</span>],
    random_seed=SEED,
)
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">Sample new &#963; with higher oop
</span><span style="color: #e95678;">idata_extended_1</span> = pm.sample_posterior_predictive(
    idata_extended,
    model=AR_model_1,
    predictions=<span style="color: #f09383;">True</span>,
    var_names=[<span style="color: #fab795;">"&#963;"</span>,<span style="color: #fab795;">"ill"</span>],
    random_seed=SEED,
)
idata_extended_0.to_netcdf(<span style="color: #fab795;">"./trace/extended_model_do_0.nc"</span>)
idata_extended_1.to_netcdf(<span style="color: #fab795;">"./trace/extended_model_do_1.nc"</span>)
</pre>
</div>

<pre class="example">
Sampling: [M_infant_observed, Physicians_observed, logodds_λ]
</pre>

<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace">/Users/janboone/anaconda3/envs/pymc_env2/lib/python3.13/site-packages/rich/live.py:256: UserWarning: install 
"ipywidgets" for Jupyter support
  warnings.warn('install "ipywidgets" for Jupyter support')
</pre>
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
<pre class="example">
Sampling: [M_infant_observed, Physicians_observed, logodds_λ]
</pre>

<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace">/Users/janboone/anaconda3/envs/pymc_env2/lib/python3.13/site-packages/rich/live.py:256: UserWarning: install 
"ipywidgets" for Jupyter support
  warnings.warn('install "ipywidgets" for Jupyter support')
</pre>
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
<pre class="example">
./trace/extended_model_do_1.nc
</pre>

<p>
And read in these trace files when we need them:
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">idata_extended_0</span> = az.from_netcdf(<span style="color: #fab795;">"./trace/extended_model_do_0.nc"</span>)
<span style="color: #e95678;">idata_extended_1</span> = az.from_netcdf(<span style="color: #fab795;">"./trace/extended_model_do_1.nc"</span>)
</pre>
</div>



<p>
In order to find the fractions of people who are ill and fit in these simulations, we need the parameters \(\pi,\delta\) and \(\sigma\) from the model. From these parameters, only \(\sigma\) differs between the baseline and the counterfactual simulation.
</p>

<p>
We want to project the effects for 40 years into the future and hence cannot use the year dimension in the model for \(\sigma\) (which is only 11 years). Therefore we take the latest year for \(\sigma\) as the most recent information for our simulations.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">pi</span> = idata_extended.posterior.&#960;.values.transpose((2,3,4,5,0,1))[:,:,:,:,:,:]
<span style="color: #e95678;">delta</span> = idata_extended.posterior.&#948;.values.transpose((2,3,4,5,6,0,1))[0]
<span style="color: #e95678;">sigma_0</span> = idata_extended_0.predictions.&#963;.values.transpose((2,3,4,5,6,0,1))[-1] <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">use latest year
</span><span style="color: #e95678;">sigma_1</span> = idata_extended_1.predictions.&#963;.values.transpose((2,3,4,5,6,0,1))[-1]
</pre>
</div>

<p>
Since we are interested in the dynamic effects of the change in oop, we consider the longest run that we have in the model: people who are 45 at the start of the simulation and we follow this cohort until they are 84.
</p>

<p>
In order to calculate/normalize the life years, we start with 1000 forty-five year olds per category gender/income and region. We use our estimate of \(\iota_0\) to split the 1000 individuals into fit and ill. Then we run through our Markov model keeping track of who switches health state and who dies. 
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">iota_0</span> = idata_extended.posterior.&#953;_0.values.transpose((2,3,4,5,0,1))[0,<span style="color: #f09383;">None</span>,:,:,:,:,:]
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">outcomes baseline:
</span><span style="color: #e95678;">shape</span> = (2,n_ages,n_g,n_regions,n_y,4,2000) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit/ill, age, gender, region, income, chain, samples
</span><span style="color: #e95678;">N_0</span> = np.zeros(shape) 
<span style="color: #e95678;">N_0</span>[0,0] = (1-iota_0)*1000 <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit
</span><span style="color: #e95678;">N_0</span>[1,0] = iota_0*1000     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">ill
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">outcomes counterfactual:
</span><span style="color: #e95678;">N_1</span> = np.zeros(shape) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit/ill, age, gender, region, income, samples
</span><span style="color: #e95678;">N_1</span>[0,0] = (1-iota_0)*1000 <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fit
</span><span style="color: #e95678;">N_1</span>[1,0] = iota_0*1000     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">ill
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">follow these 45 year olds till they are 85
</span><span style="color: #b877db;">for</span> j <span style="color: #b877db;">in</span> <span style="color: #b877db;">range</span>(1,n_ages):
   <span style="color: #e95678;">N_0</span>[0,j] = (1-pi[j-1])*N_0[0,j-1] + sigma_0 * N_0[1,j-1]
   <span style="color: #e95678;">N_0</span>[1,j] = pi[j-1]*N_0[0,j-1] + (1-sigma_0 - delta) * N_0[1,j-1] 
   <span style="color: #e95678;">N_1</span>[0,j] = (1-pi[j-1])*N_1[0,j-1] + sigma_1 * N_1[1,j-1]
   <span style="color: #e95678;">N_1</span>[1,j] = pi[j-1]*N_1[0,j-1] + (1-sigma_1 - delta) * N_1[1,j-1] 
</pre>
</div>

<p>
To calculate life years over the lifetime (from 45-84), we count a healthy life year as 1.0 and a life year while ill at <code>qaly_ill</code> and add these together. When someone dies, there are no life years left for this person (weight 0.0). The variable <code>delta_lifeyears</code> calculates the difference between life years in the baseline simulation and the counterfactual. We adjust the &rsquo;qaly&rsquo; for the ill to a value smaller than 1.0 to capture the idea that with a probability of dying above 10% per year (conditional on being ill) suggests that patients do face significant restrictions in daily life.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">qaly_ill</span> = 0.6
<span style="color: #e95678;">lifeyears_0</span> = N_0[0].<span style="color: #b877db;">sum</span>(axis=0) + qaly_ill*N_0[1].<span style="color: #b877db;">sum</span>(axis=0)
<span style="color: #e95678;">lifeyears_1</span> = N_1[0].<span style="color: #b877db;">sum</span>(axis=0) + qaly_ill*N_1[1].<span style="color: #b877db;">sum</span>(axis=0)
<span style="color: #e95678;">delta_lifeyears</span> = lifeyears_0 - lifeyears_1
</pre>
</div>

<p>
In order to summarize the results we present two qaly outcomes per country. The following code presents the unweighted average of regions into countries.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">lifeyears_per_country</span> = np.tensordot(country_region_matrix,lifeyears_0,axes=([1,1]))
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">index: country/gender/income/chain/samples</span>
</pre>
</div>

<p>
In order to compare the dynamic and static approach, use the ages 45-74 (first cohort at the start of our data; see the first row in Table <a href="#org6103c20">1</a>). Then we compare this with the dynamic estimate <code>delta_lifeyears</code> over the same age-range (that is, not the range 45-84 that we consider above).
</p>


<p>
The following code calculates the dynamic loss in life years from 45 to 74 and returns the data in the first row of Table <a href="#org3dd0539">3</a>:
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">lifeyears_0_d</span> = N_0[0,:30].<span style="color: #b877db;">sum</span>(axis=0) + qaly_ill*N_0[1,:30].<span style="color: #b877db;">sum</span>(axis=0)
<span style="color: #e95678;">lifeyears_1_d</span> = N_1[0,:30].<span style="color: #b877db;">sum</span>(axis=0) + qaly_ill*N_1[1,:30].<span style="color: #b877db;">sum</span>(axis=0)
<span style="color: #e95678;">delta_lifeyears_d_extended</span> = lifeyears_0_d - lifeyears_1_d
delta_lifeyears_d_extended.mean(axis=(1,3,4))
</pre>
</div>

<pre class="example">
array([[4.63466841, 0.41031504],
       [7.07138378, 0.74014116]])
</pre>


<p>
To find the static estimate, we do the following. For \(\iota_0\) we are only interested in the first year; hence, index 0 in the slicing of <code>ill</code> to get <code>ill_0</code>. We will compare the qaly&rsquo;s after 1 year of the introduction of \(\Delta oop\) with the counterfactual after 1 year without the increase in \(oop\). The latter is denoted <code>lifeyears_0_s</code> (with <code>s</code> for static) and the former <code>lifeyears_1_s</code>. The code returns the second row of Table <a href="#org3dd0539">3</a> (and repeats the first row for ease of reference).
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">plt.hist(delta_lifeyears_d[0,:,0].flatten(),bins=100,alpha=0.4,density=<span style="color: #f09383;">True</span>,label=<span style="color: #fab795;">"base model"</span>);
plt.hist(delta_lifeyears_d_extended[0,:,0].flatten(),bins=100,density=<span style="color: #f09383;">True</span>,alpha=0.5,label=<span style="color: #fab795;">"extended model"</span>);
plt.xlim(0,15)
plt.xlabel(<span style="color: #fab795;">"Qaly's lost"</span>)
plt.ylabel(<span style="color: #fab795;">"Density"</span>)
plt.title(<span style="color: #fab795;">"Qaly's lost for low income women due to $</span><span style="color: #f09383;">\\</span><span style="color: #fab795;">Delta oop=0.1$"</span>)
plt.legend();
</pre>
</div>


<div id="orgdbe915d" class="figure">
<p><img src="./figures/lifeyears_comparison_extended.png" alt="lifeyears_comparison_extended.png" />
</p>
</div>



<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #e95678;">ill_0</span> = idata_extended_0.predictions.ill.values[:,:,0,:,:,:,:].transpose((2,3,4,5,0,1))*1000
<span style="color: #e95678;">fit_0</span> = 1000-ill_0
<span style="color: #e95678;">fit_1_0</span> = (1-pi[:30])*fit_0 + sigma_0 * ill_0
<span style="color: #e95678;">ill_1_0</span> = pi[:30]*fit_0 + (1-sigma_0-delta) * ill_0
<span style="color: #e95678;">deaths_1_0</span> = delta * ill_1_0
<span style="color: #e95678;">lifeyears_0_s</span> = fit_1_0 + ill_1_0 * (1-delta) * qaly_ill
<span style="color: #e95678;">fit_1_1</span> = (1-pi[:30])*fit_0 + sigma_1 * ill_0
<span style="color: #e95678;">ill_1_1</span> = pi[:30]*fit_0 + (1-sigma_1-delta) * ill_0
<span style="color: #e95678;">deaths_1_1</span> = delta * ill_1_1
<span style="color: #e95678;">lifeyears_1_s</span> = fit_1_1 + ill_1_1 * (1-delta) * qaly_ill
<span style="color: #e95678;">delta_lifeyears_s</span> = (lifeyears_0_s - lifeyears_1_s).<span style="color: #b877db;">sum</span>(axis=0)
<span style="color: #b877db;">print</span>(<span style="color: #fab795;">"The qaly effect based on a one year (static) comparison:"</span>)
<span style="color: #b877db;">print</span>(delta_lifeyears_s.mean(axis=(1,3,4)))
<span style="color: #b877db;">print</span>(<span style="color: #fab795;">"The qaly effect based on a 30 year (dynamic) comparison:"</span>)
<span style="color: #b877db;">print</span>(delta_lifeyears_d.mean(axis=(1,3,4)))

</pre>
</div>

<pre class="example">
The qaly effect based on a one year (static) comparison:
[[0.22522516 0.05081225]
 [0.27514699 0.10568415]]
The qaly effect based on a 30 year (dynamic) comparison:
[[4.63466841 0.41031504]
 [7.07138378 0.74014116]]
</pre>
</div>
</div>
</div>
<div id="outline-container-org18186f3" class="outline-3">
<h3 id="org18186f3"><span class="section-number-3">6.7.</span> placebo treatment: traffic mortality&#xa0;&#xa0;&#xa0;<span class="tag"><span class="code">code</span></span></h3>
<div class="outline-text-3" id="text-6-7">
<p>
Death to due traffic accidents does not have this stock nature. Also our eurostat data does not distinguish deaths by age or sex. Hence, we test whether OOP and Unmet needs because treatment is too expensive does correlate with traffic death. This would be evidence of the causal mechanism: government has a fiscal problem and increased OOP but also reduces road quality (e.g. roads are cleaned less frequently &#x2013;also in winter&#x2013; and are maintained less frequently)
</p>

<ul class="org-ul">
<li>poverty is an effect on the roads and perhaps quality of the cars</li>
<li>the question is whether OOP feeds through unmet needs into health; the other causal interpretation is that OOP is a measure of government means and affect quality of healthcare and quality of roads; hence we add OOP in the regression for the probability of traffic mortality</li>
<li>nuts 2 fixed effects</li>
</ul>


<p>
Model Traffic_mortality as a Negative Binomial distribution:
</p>
<ul class="org-ul">
<li>has be integer</li>
<li>Poisson distribution given its parameter; parameter has Gamma distribution</li>
</ul>
</div>
<div id="outline-container-org4b9d9b8" class="outline-4">
<h4 id="org4b9d9b8">model</h4>
<div class="outline-text-4" id="text-org4b9d9b8">
<p>
We choose the priors as standard normal as we do not develop a theory for traffic accidents and its determinants.
</p>

<p>
In the model below, the parameter \(t\) has to be positive; hence we use <code>np.exp</code>. Then for the prior on the regional fixed effects of traffic mortality we use the logarithm of traffic mortality.  
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 13: </span>traffic-model</label><pre class="src src-jupyter-python" id="org058f97a">
<span style="color: #e95678;">countries</span> = np.array([<span style="color: #fab795;">'Bulgaria'</span>, <span style="color: #fab795;">'Switzerland'</span>, <span style="color: #fab795;">'Denmark'</span>, <span style="color: #fab795;">'Greece'</span>, <span style="color: #fab795;">'Finland'</span>, <span style="color: #fab795;">'Hungary'</span>, <span style="color: #fab795;">'Lithuania'</span>, <span style="color: #fab795;">'Norway'</span>, <span style="color: #fab795;">'Sweden'</span>, <span style="color: #fab795;">'Slovenia'</span>, <span style="color: #fab795;">'Slovakia'</span>])
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">index: age, gender, year, region, income
</span><span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">for some variables we use country instead of region
</span><span style="color: #e95678;">mean_traffic</span> = np.log(1+Traffic_mortality).mean(axis=0)
<span style="color: #e95678;">std_traffic</span> = np.log(1+Traffic_mortality).std()

<span style="color: #e95678;">coords</span> = {
    <span style="color: #fab795;">"region"</span> : ds.nuts2.values,\
    <span style="color: #fab795;">"year"</span> : ds.year.values,\
    <span style="color: #fab795;">"country"</span>: countries,\
     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">we define dummy dimensions for parameters that do not
</span>     <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">vary by this dimension
</span>     <span style="color: #fab795;">"dummy0"</span>: np.arange(1),\
     <span style="color: #fab795;">"dummy1"</span>: np.arange(1),\
     <span style="color: #fab795;">"dummy2"</span>: np.arange(1)}

<span style="color: #b877db;">with</span> pm.Model(coords=coords) <span style="color: #b877db;">as</span> traffic_model:
    <span style="color: #e95678;">pov</span> = pm.Normal(<span style="color: #fab795;">"pov"</span>, mean_depr[<span style="color: #f09383;">None</span>,:], std_depr[<span style="color: #f09383;">None</span>,:], observed=Deprivation,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>)) <span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">fraction of people on low income
</span>    <span style="color: #e95678;">oop_c</span> = pm.Normal(<span style="color: #fab795;">"oop_c"</span>, mean_oop_c[<span style="color: #f09383;">None</span>,:], std_oop_c[<span style="color: #f09383;">None</span>,:], observed=OOP_c,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"country"</span>))
    <span style="color: #e95678;">oop</span> = pt.dot(oop_c,country_region_matrix_01)
    <span style="color: #e95678;">M_infant</span> = pm.Normal(<span style="color: #fab795;">"M_infant"</span>,mean_m_infant[<span style="color: #f09383;">None</span>,:],std_m_infant[<span style="color: #f09383;">None</span>,:],dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>),observed=m_infant)
    <span style="color: #e95678;">Physicians</span> = pm.Normal(<span style="color: #fab795;">"Physicians"</span>,mean_physician[<span style="color: #f09383;">None</span>,:],std_physician[<span style="color: #f09383;">None</span>,:],dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>),observed=physicians)
    <span style="color: #e95678;">constant</span> = pm.Normal(<span style="color: #fab795;">"constant"</span>,mean_traffic,std_traffic)
    <span style="color: #e95678;">&#950;</span> = pm.Normal(<span style="color: #fab795;">"&#950;"</span>)
    <span style="color: #e95678;">a1</span> = pm.Normal(<span style="color: #fab795;">"a1"</span>)
    <span style="color: #e95678;">a2</span> = pm.Normal(<span style="color: #fab795;">"a2"</span>)
    <span style="color: #e95678;">a3</span> = pm.Normal(<span style="color: #fab795;">"a3"</span>)
    <span style="color: #e95678;">t</span> = np.exp(constant + &#950; * oop + a1 * pov + a2 * M_infant + a3 * Physicians)
    <span style="color: #e95678;">&#945;</span> = pm.Exponential(<span style="color: #fab795;">"&#945;"</span>, 0.5)

    <span style="color: #e95678;">t_mortality</span> = pm.NegativeBinomial(<span style="color: #fab795;">"t_mortality"</span>,mu=t, alpha=&#945;,observed=Traffic_mortality,dims=(<span style="color: #fab795;">"year"</span>,<span style="color: #fab795;">"region"</span>))

</pre>
</div>

<pre class="example">
/Users/janboone/anaconda3/envs/pymc_env/lib/python3.12/site-packages/pymc/model/core.py:1302: ImputationWarning: Data in pov contains missing values and will be automatically imputed from the sampling distribution.
  warnings.warn(impute_message, ImputationWarning)
/Users/janboone/anaconda3/envs/pymc_env/lib/python3.12/site-packages/pymc/model/core.py:1302: ImputationWarning: Data in oop_c contains missing values and will be automatically imputed from the sampling distribution.
  warnings.warn(impute_message, ImputationWarning)
/Users/janboone/anaconda3/envs/pymc_env/lib/python3.12/site-packages/pymc/model/core.py:1302: ImputationWarning: Data in M_infant contains missing values and will be automatically imputed from the sampling distribution.
  warnings.warn(impute_message, ImputationWarning)
/Users/janboone/anaconda3/envs/pymc_env/lib/python3.12/site-packages/pymc/model/core.py:1302: ImputationWarning: Data in Physicians contains missing values and will be automatically imputed from the sampling distribution.
  warnings.warn(impute_message, ImputationWarning)
</pre>
</div>
</div>
<div id="outline-container-org185a38e" class="outline-4">
<h4 id="org185a38e">sampling</h4>
<div class="outline-text-4" id="text-org185a38e">
<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #b877db;">with</span> traffic_model:
    <span style="color: #e95678;">idata_traffic</span> = pm.sample(draws=2000)
<span style="color: #4e5059; font-style: italic;"># </span><span style="color: #4e5059; font-style: italic;">idata.to_netcdf("./trace/traffic_model.nc")</span>
</pre>
</div>


<p>
We conclude that the posterior distribution of \(\zeta\) has positive mean but the standard deviation is almost double the mean. Hence, there is no clear evidence of the alternative narrative that OOP is correlated with fiscal constraints and therefore leads to lower quality of healthcare and roads.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #b877db;">print</span>(idata_traffic.posterior.&#950;.mean())
<span style="color: #b877db;">print</span>(idata_traffic.posterior.&#950;.std())
</pre>
</div>

<pre class="example">
&lt;xarray.DataArray 'ζ' ()&gt; Size: 8B
array(0.34755283)
&lt;xarray.DataArray 'ζ' ()&gt; Size: 8B
array(0.60417343)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0eec779" class="outline-2">
<h2 id="org0eec779"><span class="section-number-2">7.</span> Discussion and policy implications</h2>
<div class="outline-text-2" id="text-7">
<p>
This paper develops and estimates a dynamic structural model to assess the long-term effects of health insurance generosity on population health. By modeling transitions between health states and mortality for cohorts defined by age, gender, income and region, we are able to simulate the cumulative impact of demand-side cost-sharing on health outcomes mortality and quality-adjusted life years (qaly&rsquo;s).
</p>

<p>
Our results yield three key insights. First, increases in the fraction of out-of-pocket spending reduce population health, with particularly large effects for people on low-income. Second, the magnitude of the long-term health cost is substantially greater than what would be inferred from short-run, static estimates such as difference-in-differences. For low-incomes dynamic effects are up to twenty times larger than their static counterparts. Third, widely used methods for causal identification may deliver internally valid but incomplete assessments of health policy, particularly by ignoring the dynamics of health stocks.
</p>

<p>
These findings have broader relevance beyond the context of healthcare. They underscore the difficulties of evaluating policies whose outcomes develop gradually over time &#x2013;such as education reforms influencing human capital, climate policies impacting environmental degradation and innovation policies shaping the accumulation of knowledge. Our framework offers a template for incorporating such dynamic effects into empirical work in these fields.
</p>

<p>
Future research can build on this work in several directions. Incorporating individual-level microdata could help to refine the heterogeneity estimates and to explore alternative functional forms for treatment response in the transition probabilities. Further, gathering more data on healthcare quality and/or explicitly modeling the government&rsquo;s policy on demand-side cost-sharing in this framework can reduce confounder bias.
</p>
</div>
</div>
<div id="outline-container-org8025f66" class="outline-2">
<h2 id="org8025f66"><span class="section-number-2">8.</span> Bibliography</h2>
<div class="outline-text-2" id="text-8">
<style>.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>Borgschulte, Mark, and Jacob Vogler. 2020. “Did the Aca Medicaid Expansion Save Lives?” <i>Journal of Health Economics</i> 72 (July):102333. <a href="https://doi.org/10.1016/j.jhealeco.2020.102333">https://doi.org/10.1016/j.jhealeco.2020.102333</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_2"></a>Brot-Goldberg, Zarek C., Amitabh Chandra, Benjamin R. Handel, and Jonathan T. Kolstad. 2017. “What Does a Deductible Do? the Impact of Cost-Sharing on Health Care Prices, Quantities, and Spending Dynamics.” <i>The Quarterly Journal of Economics</i> 132 (3): 1261–1318. <a href="https://doi.org/10.1093/qje/qjx013">https://doi.org/10.1093/qje/qjx013</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_3"></a>Chandra, Amitabh, Evan Flack, and Ziad Obermeyer. 2021. “The Health Costs of Cost-Sharing,” February. <a href="https://doi.org/10.3386/w28439">https://doi.org/10.3386/w28439</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_4"></a>Finkelstein, Amy, and Robin McKnight. 2008. “What Did Medicare Do? the Initial Impact of Medicare on Mortality and out of Pocket Medical Spending.” <i>Journal of Public Economics</i> 92 (7): 1644–68. <a href="https://doi.org/10.1016/j.jpubeco.2007.10.005">https://doi.org/10.1016/j.jpubeco.2007.10.005</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_5"></a>Goldin, Jacob, Ithai Z. Lurie, and Janet McCubbin. 2020. “Health Insurance and Mortality: Experimental Evidence from Taxpayer Outreach.” <i>The Quarterly Journal of Economics</i> 136 (1): 1–49. <a href="https://doi.org/10.1093/qje/qjaa029">https://doi.org/10.1093/qje/qjaa029</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_6"></a>Gross, Tal, Timothy Layton, and Daniel Prinz. 2020. “The Liquidity Sensitivity of Healthcare Consumption: Evidence from Social Security Payments,” October. <a href="https://doi.org/10.3386/w27977">https://doi.org/10.3386/w27977</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_7"></a>Miller, Sarah, Norman Johnson, and Laura R Wherry. 2021. “Medicaid and Mortality: New Evidence from Linked Survey and Administrative Data.” <i>The Quarterly Journal of Economics</i>, January. <a href="https://doi.org/10.1093/qje/qjab004">https://doi.org/10.1093/qje/qjab004</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_8"></a>Nyman, J.A. 2003. <i>The Theory of Demand for Health Insurance</i>. Stanford University Press.</div>
</div>


<p>


</p>
</div>
</div>
<div id="outline-container-org1a41241" class="outline-2">
<h2 id="org1a41241"><span class="section-number-2">9.</span> Data</h2>
<div class="outline-text-2" id="text-9">
<p>
All our variables come from Eurostat. Table <a href="#org5604b5e">7</a> shows the dimensions over which our variables vary: country, NUTS 2, calendar year, age and sex. We also present the DOI and a clickable link to the variable on the Eurostat website for ease of reference. The file <a href="./getting_data.html">./getting_data.html</a> presents the code to download the Eurostat data.<sup><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink">8</a></sup>
</p>


<table id="org5604b5e" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 7:</span> Variables and the dimensions over which they vary.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">variable</th>
<th scope="col" class="org-left">country</th>
<th scope="col" class="org-left">NUTS 2</th>
<th scope="col" class="org-left">time</th>
<th scope="col" class="org-left">age</th>
<th scope="col" class="org-left">sex</th>
<th scope="col" class="org-left">reference</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">population</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left"><a href="https://ec.europa.eu/eurostat/databrowser/view/DEMO_R_D2JAN/default/table?lang=en&amp;category=demo.demopreg">https://doi.org/10.2908/DEMO_R_D2JAN</a></td>
</tr>

<tr>
<td class="org-left">deaths</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left"><a href="https://ec.europa.eu/eurostat/databrowser/view/DEMO_R_MAGEC/default/table?lang=en&amp;category=demo.demomreg">https://doi.org/10.2908/DEMO_R_MAGEC</a></td>
</tr>

<tr>
<td class="org-left">deprivation</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><a href="https://ec.europa.eu/eurostat/databrowser/view/tgs00104/default/table?lang=en">https://doi.org/10.2908/TGS00104</a></td>
</tr>

<tr>
<td class="org-left">too expensive</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><a href="https://ec.europa.eu/eurostat/databrowser/view/hlth_silc_08_r/default/table?lang=en">https://doi.org/10.2908/HLTH_SILC_08_R</a></td>
</tr>

<tr>
<td class="org-left">unmet</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><a href="https://ec.europa.eu/eurostat/databrowser/view/hlth_silc_08_r/default/table?lang=en">https://doi.org/10.2908/HLTH_SILC_08_R</a></td>
</tr>

<tr>
<td class="org-left">infant mortality</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><a href="https://ec.europa.eu/eurostat/databrowser/view/DEMO_R_MINFIND/default/table?lang=en&amp;category=demo.demomreg">https://doi.org/10.2908/DEMO_R_MINFIND</a></td>
</tr>

<tr>
<td class="org-left">number of physicians</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><a href="https://ec.europa.eu/eurostat/databrowser/view/hlth_rs_physreg/default/table?lang=en&amp;category=hlth.hlth_care.hlth_res.hlth_staff">https://doi.org/10.2908/HLTH_RS_PHYSREG</a></td>
</tr>

<tr>
<td class="org-left">out-of-pocket</td>
<td class="org-left">x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><a href="https://ec.europa.eu/eurostat/databrowser/view/hlth_sha11_hf/default/table?lang=en">https://doi.org/10.2908/HLTH_SHA11_HF</a></td>
</tr>

<tr>
<td class="org-left">traffic mortality</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><a href="https://ec.europa.eu/eurostat/databrowser/view/tran_r_acci/default/table?lang=en">https://doi.org/10.2908/TRAN_R_ACCI</a></td>
</tr>

<tr>
<td class="org-left">GDP per capita</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><a href="https://ec.europa.eu/eurostat/databrowser/view/nama_10r_2gdp/default/table?lang=en">https://doi.org/10.2908/NAMA_10R_2GDP</a></td>
</tr>

<tr>
<td class="org-left">unemployment</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><a href="https://ec.europa.eu/eurostat/databrowser/view/lfst_r_lfur2gan/default/table">https://doi.org/10.2908/LFST_R_LFUR2GAN</a></td>
</tr>

<tr>
<td class="org-left">tertiary education</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><a href="https://ec.europa.eu/eurostat/databrowser/view/tgs00109/default/table?lang=en&amp;category=t_reg.t_reg_educ">https://doi.org/10.2908/TGS00109</a></td>
</tr>

<tr>
<td class="org-left">devices for medical imaging</td>
<td class="org-left">x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">x</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><a href="https://ec.europa.eu/eurostat/databrowser/view/hlth_rs_medim/default/table?lang=en">https://doi.org/10.2908/HLTH_RS_MEDIM</a></td>
</tr>
</tbody>
</table>



<p>
The variables on deprivation and access to care (unmet and too expensive) come from the <a href="https://ec.europa.eu/eurostat/statistics-explained/index.php?title=EU_statistics_on_income_and_living_conditions_(EU-SILC)_methodology">EU statistics on income and living conditions (EU-SILC)</a> survey.
</p>

<p>
From the <a href="https://ec.europa.eu/eurostat/statistics-explained/index.php?title=Glossary:At-risk-of-poverty_rate">Eurostat Glossary:</a> &ldquo;<a href="https://ec.europa.eu/eurostat/statistics-explained/index.php?title=Glossary:Material_deprivation">Material deprivation</a> refers to a state of economic strain and durables, defined as the enforced inability (rather than the choice not to do so) to pay unexpected expenses, afford a one-week annual holiday away from home, a meal involving meat, chicken or fish every second day, the adequate heating of a dwelling, durable goods like a washing machine, colour television, telephone or car, being confronted with payment arrears (mortgage or rent, utility bills, hire purchase instalments or other loan payments).&rdquo; Our variable &ldquo;material deprivation&rdquo; equals the share of people in a NUTS 2 region in material deprivation.
</p>

<p>
Fraction of people with self-reported unmet needs for medical examination is based on the same survey. In particular, the definition of this item is &ldquo;Self-reported unmet needs for health care: Proportion of people in need of health care reporting to have experienced delay in getting health care in the previous 12 months for reasons of financial barriers, long waiting lists, distance or transportation problems.&rdquo; We use both the general definition of unmet needs and the specific reason that treatment was too expensive.
</p>

<p>
Infant mortality measures the number of deaths of infants per 1000 live births in a year at the NUTS 2 region level.
</p>

<p>
We measure the number of physicians per 100k inhabitants per NUTS 2 region and calendar year. It gives an idea of the resources spent on healthcare in a region. Together with infant mortality and unmet medical needs it gives an idea of healthcare quality in a region.
</p>

<p>
We characterize how generous a health insurance system is using the variable <code>OOP</code> in our analysis. This variable is derived from data on health care expenditure by financing scheme at the country level. For our <code>OOP</code> measure we focus on household out-of-pocket payment (<code>out-of-pocket</code>) as share of total current health expenditure.
</p>

<p>
In the model extensions we also use GPD per capita and devices for medical imaging as signals of healthcare quality. Unemployment and education capture regional deviations from average health status across age and gender.
</p>

<p>
Finally, we use traffic mortality in our placebo treatment where changes in out-of-pocket payments are not expected to change mortality.
</p>
</div>
</div>
<div id="outline-container-orga14992a" class="outline-2">
<h2 id="orga14992a"><span class="section-number-2">10.</span> Estimation</h2>
<div class="outline-text-2" id="text-10">
<p>
Table <a href="#orgb8e8f7b">8</a> shows the details of the parameters in the model that do not have too many indices. To illustrate we do not present the results for <code>logodds_age_π</code> as this would entail 40 rows in the table.
</p>

<p>
The value of <code>r_hat</code> is equal or close to one for all variables. This suggests that the NUTS algorithm converged in drawing samples from the posterior distribution. The probability of falling ill is clearly lower for women than for men. The increase in the fraction of people forgoing treatment because it is too expensive, \(\zeta\), is higher for low incomes than for high incomes. The \(\nu\) parameter of the Beta distribution is sometimes referred to as sample size. For the distribution of the fraction of people reporting unmet medical needs due to reasons other than the treatment being too expensive, \(\nu_{U_{o}}\) is above 100. For the fraction of people reporting unmet medical needs (for any reason) \(\nu_U\) is close to 300. The variable \(\varepsilon\) captures the extent to which unmet medical needs for other reasons than too expensive originates with low incomes compared to high incomes. Although the posterior expectation of \(\varepsilon\) is positive, zero is part of the 94% credibility interval. The uncertainty of this parameter, including that \(\varepsilon\) equals zero, is propagated through our results and simulated outcomes. Finally, \(\lambda_1\) equals the (negative) effect of healthcare quality as measured by infant mortality on the log odds of \(\lambda\), the probability of recovery conditional on being treated. When measuring quality with the number of physicians per 100k inhabitants, \(\lambda_2\) captures the effect on the log odds of \(\lambda\).
</p>
\begin{equation}
\label{org1248da6}
\log(\lambda/(1-\lambda)) = \lambda_0 - \lambda_1 M_{infant} + \lambda_2 N_{physician}
\end{equation}
<p>
where \(\lambda_0\) varies by year to capture technical progress, \(M_{infant}\) measures infant mortality and \(N_{physician}\) the number of physicians. The table shows that \(\lambda_1\) is positive in expectation but can be zero. For \(\lambda_2\) there is clearer evidence that the effect of physicians on recovery is positive.
</p>





<table id="orgb8e8f7b" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 8:</span> Estimated parameters of the main model</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">mean</th>
<th scope="col" class="org-right">sd</th>
<th scope="col" class="org-right">hdi_3%</th>
<th scope="col" class="org-right">hdi_97%</th>
<th scope="col" class="org-right">ess_bulk</th>
<th scope="col" class="org-right">r_hat</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">logodds_sex_π[F]</td>
<td class="org-right">-0.19</td>
<td class="org-right">0.03</td>
<td class="org-right">-0.25</td>
<td class="org-right">-0.13</td>
<td class="org-right">349.00</td>
<td class="org-right">1.01</td>
</tr>

<tr>
<td class="org-left">logodds_sex_π[M]</td>
<td class="org-right">0.50</td>
<td class="org-right">0.03</td>
<td class="org-right">0.44</td>
<td class="org-right">0.56</td>
<td class="org-right">354.00</td>
<td class="org-right">1.01</td>
</tr>

<tr>
<td class="org-left">ζ[y_l]</td>
<td class="org-right">0.27</td>
<td class="org-right">0.01</td>
<td class="org-right">0.25</td>
<td class="org-right">0.30</td>
<td class="org-right">8429.00</td>
<td class="org-right">1.00</td>
</tr>

<tr>
<td class="org-left">ζ[y_h]</td>
<td class="org-right">0.03</td>
<td class="org-right">0.00</td>
<td class="org-right">0.03</td>
<td class="org-right">0.04</td>
<td class="org-right">6048.00</td>
<td class="org-right">1.00</td>
</tr>

<tr>
<td class="org-left">nu_U</td>
<td class="org-right">299.81</td>
<td class="org-right">18.94</td>
<td class="org-right">264.86</td>
<td class="org-right">336.40</td>
<td class="org-right">7950.00</td>
<td class="org-right">1.00</td>
</tr>

<tr>
<td class="org-left">nu_U_o</td>
<td class="org-right">109.35</td>
<td class="org-right">6.59</td>
<td class="org-right">97.78</td>
<td class="org-right">122.34</td>
<td class="org-right">5584.00</td>
<td class="org-right">1.00</td>
</tr>

<tr>
<td class="org-left">ε</td>
<td class="org-right">0.07</td>
<td class="org-right">0.07</td>
<td class="org-right">0.00</td>
<td class="org-right">0.19</td>
<td class="org-right">10331.00</td>
<td class="org-right">1.00</td>
</tr>

<tr>
<td class="org-left">lambda_1</td>
<td class="org-right">0.01</td>
<td class="org-right">0.01</td>
<td class="org-right">0.00</td>
<td class="org-right">0.02</td>
<td class="org-right">6389.00</td>
<td class="org-right">1.00</td>
</tr>

<tr>
<td class="org-left">lambda_2</td>
<td class="org-right">0.06</td>
<td class="org-right">0.01</td>
<td class="org-right">0.04</td>
<td class="org-right">0.07</td>
<td class="org-right">1704.00</td>
<td class="org-right">1.01</td>
</tr>
</tbody>
</table>


<p>
Figure <a href="#orge50c38e">7</a> shows the traceplots for the main parameters of the model. We check the following three characteristics of the plots. First, the plot is stationary; that is, not trending upward or downward. This implies that the posterior mean of the coefficient is (more or less) constant as we sample. Second, there is good mixing which translates in condensed zig-zagging. In other words, the algorithm manages to draw values across the whole domain of the posterior quickly one after the other. Finally, the four chains cover the same regions. All three features are satisfied for the coefficients in the figure.
</p>




<div id="orge50c38e" class="figure">
<p><img src="./figures/trace.png" alt="trace.png" />
</p>
<p><span class="figure-number">Figure 7: </span>Traceplot for the main model</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">See the github repository: <a href="https://github.com/janboone/dynamic-effects-of-health-insurance-reform">https://github.com/janboone/dynamic-effects-of-health-insurance-reform</a>.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">We use an undiscounted sum here to make it easier to compare to the static version \(\tilde Q\) discussed below.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">The max. number of observations that we could have is: 65 (regions) \(*\) 11 (years) \(*\) 30 (ages) \(*\) 2 (genders) \(=42,900\) which we have in first three rows. For the next 5 rows in the table we have data for at max. 11 years and 65 regions which corresponds to 715 obervations and for out-of-pocket we have at max. 11 years and 11 countries corresponding to 121.</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Eurostat also provides the variable &ldquo;at-risk-of-poverty&rdquo; per NUTS 2 region. This is a relative poverty measure: the share of people with disposable income after social transfers below a threshold based on the national median disposable income. But the link between this poverty measure and forgoing treatment because it is too expensive is weaker. Further, there are more missing observations for this variable than for the deprivation variable.</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">These probabilities are calculated by averaging \(\pi_{ar}^{ij}\) over region \(r\) and income \(j\).</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">This overall effect is not reported separately in the figure.</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">For the first three variables we have eleven years of data for 65 regions which would mean 715 observations, but there are some missing values. Data on tertiary education only starts from 2013 and has max. 390 observations. Finally, for the imaging devices there are 121 observations and no missing values.</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">This file can be found in the github repository: <a href="https://github.com/janboone/dynamic-effects-of-health-insurance-reform">https://github.com/janboone/dynamic-effects-of-health-insurance-reform</a>.</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
